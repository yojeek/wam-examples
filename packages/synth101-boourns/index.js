/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ "use strict";
/******/ var __webpack_modules__ = ({

/***/ "../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CompositeAudioNode\": () => (/* binding */ CompositeAudioNode),\n/* harmony export */   \"ParamMgrFactory\": () => (/* binding */ ParamMgrFactory)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/CompositeAudioNode.js\nvar CompositeAudioNode = class extends GainNode {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"_output\");\n    __publicField(this, \"_wamNode\");\n  }\n  get groupId() {\n    return this._wamNode.groupId;\n  }\n  get moduleId() {\n    return this._wamNode.moduleId;\n  }\n  get instanceId() {\n    return this._wamNode.instanceId;\n  }\n  get module() {\n    return this._wamNode.module;\n  }\n  addEventListener(...args) {\n    return this._wamNode.addEventListener(...args);\n  }\n  removeEventListener(...args) {\n    return this._wamNode.removeEventListener(...args);\n  }\n  dispatchEvent(...args) {\n    return this._wamNode.dispatchEvent(...args);\n  }\n  getParameterInfo(...args) {\n    return this._wamNode.getParameterInfo(...args);\n  }\n  getParameterValues(...args) {\n    return this._wamNode.getParameterValues(...args);\n  }\n  setParameterValues(...args) {\n    return this._wamNode.setParameterValues(...args);\n  }\n  getState() {\n    return this._wamNode.getState();\n  }\n  setState(...args) {\n    return this._wamNode.setState(...args);\n  }\n  getCompensationDelay() {\n    return this._wamNode.getCompensationDelay();\n  }\n  scheduleEvents(...args) {\n    return this._wamNode.scheduleEvents(...args);\n  }\n  clearEvents() {\n    return this._wamNode.clearEvents();\n  }\n  connectEvents(...args) {\n    return this._wamNode.connectEvents(...args);\n  }\n  disconnectEvents(...args) {\n    return this._wamNode.disconnectEvents(...args);\n  }\n  destroy() {\n    return this._wamNode.destroy();\n  }\n  set channelCount(count) {\n    if (this._output)\n      this._output.channelCount = count;\n    else\n      super.channelCount = count;\n  }\n  get channelCount() {\n    if (this._output)\n      return this._output.channelCount;\n    return super.channelCount;\n  }\n  set channelCountMode(mode) {\n    if (this._output)\n      this._output.channelCountMode = mode;\n    else\n      super.channelCountMode = mode;\n  }\n  get channelCountMode() {\n    if (this._output)\n      return this._output.channelCountMode;\n    return super.channelCountMode;\n  }\n  set channelInterpretation(interpretation) {\n    if (this._output)\n      this._output.channelInterpretation = interpretation;\n    else\n      super.channelInterpretation = interpretation;\n  }\n  get channelInterpretation() {\n    if (this._output)\n      return this._output.channelInterpretation;\n    return super.channelInterpretation;\n  }\n  get numberOfInputs() {\n    return super.numberOfInputs;\n  }\n  get numberOfOutputs() {\n    if (this._output)\n      return this._output.numberOfOutputs;\n    return super.numberOfOutputs;\n  }\n  get gain() {\n    return void 0;\n  }\n  connect(...args) {\n    if (this._output && this._output !== this)\n      return this._output.connect(...args);\n    return super.connect(...args);\n  }\n  disconnect(...args) {\n    if (this._output && this._output !== this)\n      return this._output.disconnect(...args);\n    return super.disconnect(...args);\n  }\n};\n\n// src/sdk/src/addFunctionModule.js\nvar addFunctionModule = (audioWorklet, processorFunction, ...injection) => {\n  const text = `(${processorFunction.toString()})(${injection.map((s) => JSON.stringify(s)).join(\", \")});`;\n  const url = URL.createObjectURL(new Blob([text], { type: \"text/javascript\" }));\n  return audioWorklet.addModule(url);\n};\nvar addFunctionModule_default = addFunctionModule;\n\n// src/ParamMgrProcessor.js\nvar processor = (moduleId, paramsConfig) => {\n  const audioWorkletGlobalScope = globalThis;\n  const {\n    AudioWorkletProcessor,\n    registerProcessor,\n    webAudioModules\n  } = audioWorkletGlobalScope;\n  const supportSharedArrayBuffer = !!globalThis.SharedArrayBuffer;\n  const SharedArrayBuffer = globalThis.SharedArrayBuffer || globalThis.ArrayBuffer;\n  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n  const normalizeE = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n  const normalize = (x, min, max) => min === 0 && max === 1 ? x : (x - min) / (max - min) || 0;\n  const denormalize = (x, min, max) => min === 0 && max === 1 ? x : x * (max - min) + min;\n  const mapValue = (x, eMin, eMax, sMin, sMax, tMin, tMax) => denormalize(normalize(normalize(Math.min(sMax, Math.max(sMin, x)), eMin, eMax), normalize(sMin, eMin, eMax), normalize(sMax, eMin, eMax)), tMin, tMax);\n  class ParamMgrProcessor extends AudioWorkletProcessor {\n    static get parameterDescriptors() {\n      return Object.entries(paramsConfig).map(([name, { defaultValue, minValue, maxValue }]) => ({\n        name,\n        defaultValue,\n        minValue,\n        maxValue\n      }));\n    }\n    constructor(options) {\n      super(options);\n      this.destroyed = false;\n      this.supportSharedArrayBuffer = supportSharedArrayBuffer;\n      const {\n        paramsMapping,\n        internalParamsMinValues,\n        internalParams,\n        groupId,\n        instanceId\n      } = options.processorOptions;\n      this.groupId = groupId;\n      this.moduleId = moduleId;\n      this.instanceId = instanceId;\n      this.internalParamsMinValues = internalParamsMinValues;\n      this.paramsConfig = paramsConfig;\n      this.paramsMapping = paramsMapping;\n      this.paramsValues = {};\n      Object.entries(paramsConfig).forEach(([name, { defaultValue }]) => {\n        this.paramsValues[name] = defaultValue;\n      });\n      this.internalParams = internalParams;\n      this.internalParamsCount = this.internalParams.length;\n      this.buffer = new SharedArrayBuffer((this.internalParamsCount + 1) * Float32Array.BYTES_PER_ELEMENT);\n      this.$lock = new Int32Array(this.buffer, 0, 1);\n      this.$internalParamsBuffer = new Float32Array(this.buffer, 4, this.internalParamsCount);\n      this.eventQueue = [];\n      this.handleEvent = null;\n      audioWorkletGlobalScope.webAudioModules.addWam(this);\n      this.messagePortRequestId = -1;\n      const resolves = {};\n      const rejects = {};\n      this.call = (call, ...args) => new Promise((resolve, reject) => {\n        const id = this.messagePortRequestId--;\n        resolves[id] = resolve;\n        rejects[id] = reject;\n        this.port.postMessage({ id, call, args });\n      });\n      this.handleMessage = ({ data }) => {\n        const { id, call, args, value, error } = data;\n        if (call) {\n          const r = { id };\n          try {\n            r.value = this[call](...args);\n          } catch (e) {\n            r.error = e;\n          }\n          this.port.postMessage(r);\n        } else {\n          if (error) {\n            if (rejects[id])\n              rejects[id](error);\n            delete rejects[id];\n            return;\n          }\n          if (resolves[id]) {\n            resolves[id](value);\n            delete resolves[id];\n          }\n        }\n      };\n      this.port.start();\n      this.port.addEventListener(\"message\", this.handleMessage);\n    }\n    setParamsMapping(mapping) {\n      this.paramsMapping = mapping;\n    }\n    getBuffer() {\n      return { lock: this.$lock, paramsBuffer: this.$internalParamsBuffer };\n    }\n    getCompensationDelay() {\n      return 128;\n    }\n    getParameterInfo(...parameterIdQuery) {\n      if (parameterIdQuery.length === 0)\n        parameterIdQuery = Object.keys(this.paramsConfig);\n      const parameterInfo = {};\n      parameterIdQuery.forEach((parameterId) => {\n        parameterInfo[parameterId] = this.paramsConfig[parameterId];\n      });\n      return parameterInfo;\n    }\n    getParameterValues(normalized, ...parameterIdQuery) {\n      if (parameterIdQuery.length === 0)\n        parameterIdQuery = Object.keys(this.paramsConfig);\n      const parameterValues = {};\n      parameterIdQuery.forEach((parameterId) => {\n        if (!(parameterId in this.paramsValues))\n          return;\n        const { minValue, maxValue, exponent } = this.paramsConfig[parameterId];\n        const value = this.paramsValues[parameterId];\n        parameterValues[parameterId] = {\n          id: parameterId,\n          value: normalized ? normalizeE(value, minValue, maxValue, exponent) : value,\n          normalized\n        };\n      });\n      return parameterValues;\n    }\n    scheduleEvents(...events) {\n      this.eventQueue.push(...events);\n      const { currentTime } = audioWorkletGlobalScope;\n      this.eventQueue.sort((a, b) => (a.time || currentTime) - (b.time || currentTime));\n    }\n    emitEvents(...events) {\n      webAudioModules.emitEvents(this, ...events);\n    }\n    clearEvents() {\n      this.eventQueue = [];\n    }\n    lock() {\n      if (globalThis.Atomics)\n        Atomics.store(this.$lock, 0, 1);\n    }\n    unlock() {\n      if (globalThis.Atomics)\n        Atomics.store(this.$lock, 0, 0);\n    }\n    process(inputs, outputs, parameters) {\n      if (this.destroyed)\n        return false;\n      const outputOffset = 1;\n      this.lock();\n      Object.entries(this.paramsConfig).forEach(([name, { minValue, maxValue }]) => {\n        const raw = parameters[name];\n        if (name in this.paramsValues)\n          this.paramsValues[name] = raw[raw.length - 1];\n        if (!this.paramsMapping[name])\n          return;\n        Object.entries(this.paramsMapping[name]).forEach(([targetName, targetMapping]) => {\n          const j = this.internalParams.indexOf(targetName);\n          if (j === -1)\n            return;\n          const intrinsicValue = this.internalParamsMinValues[j];\n          const { sourceRange, targetRange } = targetMapping;\n          const [sMin, sMax] = sourceRange;\n          const [tMin, tMax] = targetRange;\n          let out;\n          if (minValue !== tMin || maxValue !== tMax || minValue !== sMin || maxValue !== sMax) {\n            out = raw.map((v) => {\n              const mappedValue = mapValue(v, minValue, maxValue, sMin, sMax, tMin, tMax);\n              return mappedValue - intrinsicValue;\n            });\n          } else if (intrinsicValue) {\n            out = raw.map((v) => v - intrinsicValue);\n          } else {\n            out = raw;\n          }\n          if (out.length === 1)\n            outputs[j + outputOffset][0].fill(out[0]);\n          else\n            outputs[j + outputOffset][0].set(out);\n          this.$internalParamsBuffer[j] = out[0];\n        });\n      });\n      this.unlock();\n      if (!this.supportSharedArrayBuffer) {\n        this.call(\"setBuffer\", { lock: this.$lock, paramsBuffer: this.$internalParamsBuffer });\n      }\n      const { currentTime } = audioWorkletGlobalScope;\n      let $event;\n      for ($event = 0; $event < this.eventQueue.length; $event++) {\n        const event = this.eventQueue[$event];\n        if (event.time && event.time > currentTime)\n          break;\n        if (typeof this.handleEvent === \"function\")\n          this.handleEvent(event);\n        this.call(\"dispatchWamEvent\", event);\n      }\n      if ($event)\n        this.eventQueue.splice(0, $event);\n      return true;\n    }\n    connectEvents(wamInstanceId, output) {\n      webAudioModules.connectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    disconnectEvents(wamInstanceId, output) {\n      if (typeof wamInstanceId === \"undefined\") {\n        webAudioModules.disconnectEvents(this.groupId, this.instanceId);\n        return;\n      }\n      webAudioModules.disconnectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    destroy() {\n      audioWorkletGlobalScope.webAudioModules.removeWam(this);\n      this.destroyed = true;\n      this.port.close();\n    }\n  }\n  try {\n    registerProcessor(moduleId, ParamMgrProcessor);\n  } catch (error) {\n    console.warn(error);\n  }\n};\nvar ParamMgrProcessor_default = processor;\n\n// src/sdk/src/WamParameterInfo.js\nvar getWamParameterInfo = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n  const denormExp = (x, e) => e === 0 ? x : x ** 1.5 ** e;\n  const normalize = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n  const denormalize = (x, min, max, e = 0) => min === 0 && max === 1 ? denormExp(x, e) : denormExp(x, e) * (max - min) + min;\n  const inRange = (x, min, max) => x >= min && x <= max;\n  class WamParameterInfo2 {\n    constructor(id, config = {}) {\n      let {\n        type,\n        label,\n        defaultValue,\n        minValue,\n        maxValue,\n        discreteStep,\n        exponent,\n        choices,\n        units\n      } = config;\n      if (type === void 0)\n        type = \"float\";\n      if (label === void 0)\n        label = \"\";\n      if (defaultValue === void 0)\n        defaultValue = 0;\n      if (choices === void 0)\n        choices = [];\n      if (type === \"boolean\" || type === \"choice\") {\n        discreteStep = 1;\n        minValue = 0;\n        if (choices.length)\n          maxValue = choices.length - 1;\n        else\n          maxValue = 1;\n      } else {\n        if (minValue === void 0)\n          minValue = 0;\n        if (maxValue === void 0)\n          maxValue = 1;\n        if (discreteStep === void 0)\n          discreteStep = 0;\n        if (exponent === void 0)\n          exponent = 0;\n        if (units === void 0)\n          units = \"\";\n      }\n      const errBase = `Param config error | ${id}: `;\n      if (minValue >= maxValue)\n        throw Error(errBase.concat(\"minValue must be less than maxValue\"));\n      if (!inRange(defaultValue, minValue, maxValue))\n        throw Error(errBase.concat(\"defaultValue out of range\"));\n      if (discreteStep % 1 || discreteStep < 0) {\n        throw Error(errBase.concat(\"discreteStep must be a non-negative integer\"));\n      } else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n        throw Error(errBase.concat(\"non-zero discreteStep requires integer minValue, maxValue, and defaultValue\"));\n      }\n      if (type === \"choice\" && !choices.length) {\n        throw Error(errBase.concat(\"choice type parameter requires list of strings in choices\"));\n      }\n      this.id = id;\n      this.label = label;\n      this.type = type;\n      this.defaultValue = defaultValue;\n      this.minValue = minValue;\n      this.maxValue = maxValue;\n      this.discreteStep = discreteStep;\n      this.exponent = exponent;\n      this.choices = choices;\n      this.units = units;\n    }\n    normalize(value) {\n      return normalize(value, this.minValue, this.maxValue, this.exponent);\n    }\n    denormalize(valueNorm) {\n      return denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n    }\n    valueString(value) {\n      if (this.choices)\n        return this.choices[value];\n      if (this.units !== \"\")\n        return `${value} ${this.units}`;\n      return `${value}`;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameterInfo)\n      ModuleScope.WamParameterInfo = WamParameterInfo2;\n  }\n  return WamParameterInfo2;\n};\nvar WamParameterInfo_default = getWamParameterInfo;\n\n// src/ParamConfigurator.js\nvar WamParameterInfo = WamParameterInfo_default();\nvar ParamMappingConfigurator = class {\n  constructor(options = {}) {\n    __publicField(this, \"_paramsConfig\");\n    __publicField(this, \"_internalParamsConfig\");\n    __publicField(this, \"_paramsMapping\", {});\n    const { paramsConfig, paramsMapping, internalParamsConfig } = options;\n    this._paramsConfig = paramsConfig;\n    this._paramsMapping = paramsMapping;\n    this._internalParamsConfig = internalParamsConfig;\n  }\n  get paramsConfig() {\n    const { internalParamsConfig } = this;\n    return Object.entries(this._paramsConfig || internalParamsConfig).reduce((configs, [id, config]) => {\n      var _a, _b, _c, _d;\n      const internalParam = internalParamsConfig[id];\n      configs[id] = new WamParameterInfo(id, __spreadProps(__spreadValues({}, config), {\n        label: (_a = config.label) != null ? _a : id,\n        defaultValue: (_b = config.defaultValue) != null ? _b : internalParam == null ? void 0 : internalParam.defaultValue,\n        minValue: (_c = config.minValue) != null ? _c : internalParam == null ? void 0 : internalParam.minValue,\n        maxValue: (_d = config.maxValue) != null ? _d : internalParam == null ? void 0 : internalParam.maxValue\n      }));\n      return configs;\n    }, {});\n  }\n  get internalParamsConfig() {\n    return Object.entries(this._internalParamsConfig || {}).reduce((configs, [name, config]) => {\n      if (config instanceof AudioParam)\n        configs[name] = config;\n      else {\n        const defaultConfig = {\n          minValue: 0,\n          maxValue: 1,\n          defaultValue: 0,\n          automationRate: 30\n        };\n        configs[name] = __spreadValues(__spreadValues({}, defaultConfig), config);\n      }\n      return configs;\n    }, {});\n  }\n  get paramsMapping() {\n    const declared = this._paramsMapping || {};\n    const externalParams = this.paramsConfig;\n    const internalParams = this.internalParamsConfig;\n    return Object.entries(externalParams).reduce((mapping, [name, { minValue, maxValue }]) => {\n      const sourceRange = [minValue, maxValue];\n      const defaultMapping = { sourceRange, targetRange: [...sourceRange] };\n      if (declared[name]) {\n        const declaredTargets = Object.entries(declared[name]).reduce((targets, [targetName, targetMapping]) => {\n          if (internalParams[targetName]) {\n            targets[targetName] = __spreadValues(__spreadValues({}, defaultMapping), targetMapping);\n          }\n          return targets;\n        }, {});\n        mapping[name] = declaredTargets;\n      } else if (internalParams[name]) {\n        mapping[name] = { [name]: __spreadValues({}, defaultMapping) };\n      }\n      return mapping;\n    }, {});\n  }\n};\n\n// src/MgrAudioParam.js\nvar MgrAudioParam = class extends AudioParam {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"_info\");\n  }\n  get exponent() {\n    return this.info.exponent;\n  }\n  get info() {\n    return this._info;\n  }\n  set info(info) {\n    this._info = info;\n  }\n  set normalizedValue(valueIn) {\n    this.value = this.info.denormalize(valueIn);\n  }\n  get normalizedValue() {\n    return this.info.normalize(this.value);\n  }\n  setValueAtTime(value, startTime) {\n    return super.setValueAtTime(value, startTime);\n  }\n  setNormalizedValueAtTime(valueIn, startTime) {\n    const value = this.info.denormalize(valueIn);\n    return this.setValueAtTime(value, startTime);\n  }\n  linearRampToValueAtTime(value, endTime) {\n    return super.linearRampToValueAtTime(value, endTime);\n  }\n  linearRampToNormalizedValueAtTime(valueIn, endTime) {\n    const value = this.info.denormalize(valueIn);\n    return this.linearRampToValueAtTime(value, endTime);\n  }\n  exponentialRampToValueAtTime(value, endTime) {\n    return super.exponentialRampToValueAtTime(value, endTime);\n  }\n  exponentialRampToNormalizedValueAtTime(valueIn, endTime) {\n    const value = this.info.denormalize(valueIn);\n    return this.exponentialRampToValueAtTime(value, endTime);\n  }\n  setTargetAtTime(target, startTime, timeConstant) {\n    return super.setTargetAtTime(target, startTime, timeConstant);\n  }\n  setNormalizedTargetAtTime(targetIn, startTime, timeConstant) {\n    const target = this.info.denormalize(targetIn);\n    return this.setTargetAtTime(target, startTime, timeConstant);\n  }\n  setValueCurveAtTime(values, startTime, duration) {\n    return super.setValueCurveAtTime(values, startTime, duration);\n  }\n  setNormalizedValueCurveAtTime(valuesIn, startTime, duration) {\n    const values = Array.from(valuesIn).map((v) => this.info.denormalize(v));\n    return this.setValueCurveAtTime(values, startTime, duration);\n  }\n  cancelScheduledParamValues(cancelTime) {\n    return super.cancelScheduledValues(cancelTime);\n  }\n  cancelAndHoldParamAtTime(cancelTime) {\n    return super.cancelAndHoldAtTime(cancelTime);\n  }\n};\n\n// src/ParamMgrNode.js\nvar AudioWorkletNode = globalThis.AudioWorkletNode;\nvar ParamMgrNode = class extends AudioWorkletNode {\n  constructor(module, options) {\n    super(module.audioContext, module.moduleId, {\n      numberOfInputs: 0,\n      numberOfOutputs: 1 + options.processorOptions.internalParams.length,\n      parameterData: options.parameterData,\n      processorOptions: options.processorOptions\n    });\n    __publicField(this, \"requestDispatchIParamChange\", (name) => {\n      const config = this.internalParamsConfig[name];\n      if (!(\"onChange\" in config))\n        return;\n      const { automationRate, onChange } = config;\n      if (typeof automationRate !== \"number\" || !automationRate)\n        return;\n      const interval = 1e3 / automationRate;\n      const i = this.internalParams.indexOf(name);\n      if (i === -1)\n        return;\n      if (i >= this.internalParams.length)\n        return;\n      if (typeof this.paramsUpdateCheckFnRef[i] === \"number\") {\n        window.clearTimeout(this.paramsUpdateCheckFnRef[i]);\n      }\n      this.paramsUpdateCheckFn[i] = () => {\n        const prev = this.$prevParamsBuffer[i];\n        const cur = this.$paramsBuffer[i];\n        if (cur !== prev) {\n          onChange(cur, prev);\n          this.$prevParamsBuffer[i] = cur;\n        }\n        this.paramsUpdateCheckFnRef[i] = window.setTimeout(this.paramsUpdateCheckFn[i], interval);\n      };\n      this.paramsUpdateCheckFn[i]();\n    });\n    const { processorOptions, internalParamsConfig } = options;\n    this.initialized = false;\n    this.module = module;\n    this.paramsConfig = processorOptions.paramsConfig;\n    this.internalParams = processorOptions.internalParams;\n    this.internalParamsConfig = internalParamsConfig;\n    this.$prevParamsBuffer = new Float32Array(this.internalParams.length);\n    this.paramsUpdateCheckFn = [];\n    this.paramsUpdateCheckFnRef = [];\n    this.messageRequestId = 0;\n    Object.entries(this.getParams()).forEach(([name, param]) => {\n      Object.setPrototypeOf(param, MgrAudioParam.prototype);\n      param._info = this.paramsConfig[name];\n    });\n    const resolves = {};\n    const rejects = {};\n    this.call = (call, ...args) => {\n      const id = this.messageRequestId;\n      this.messageRequestId += 1;\n      return new Promise((resolve, reject) => {\n        resolves[id] = resolve;\n        rejects[id] = reject;\n        this.port.postMessage({ id, call, args });\n      });\n    };\n    this.handleMessage = ({ data }) => {\n      const { id, call, args, value, error } = data;\n      if (call) {\n        const r = { id };\n        try {\n          r.value = this[call](...args);\n        } catch (e) {\n          r.error = e;\n        }\n        this.port.postMessage(r);\n      } else {\n        if (error) {\n          if (rejects[id])\n            rejects[id](error);\n          delete rejects[id];\n          return;\n        }\n        if (resolves[id]) {\n          resolves[id](value);\n          delete resolves[id];\n        }\n      }\n    };\n    this.port.start();\n    this.port.addEventListener(\"message\", this.handleMessage);\n  }\n  get parameters() {\n    return super.parameters;\n  }\n  get groupId() {\n    return this.module.groupId;\n  }\n  get moduleId() {\n    return this.module.moduleId;\n  }\n  get instanceId() {\n    return this.module.instanceId;\n  }\n  async initialize() {\n    const response = await this.call(\"getBuffer\");\n    const { lock, paramsBuffer } = response;\n    this.$lock = lock;\n    this.$paramsBuffer = paramsBuffer;\n    const offset = 1;\n    Object.entries(this.internalParamsConfig).forEach(([name, config], i) => {\n      if (this.context.state === \"suspended\")\n        this.$paramsBuffer[i] = config.defaultValue;\n      if (config instanceof AudioParam) {\n        try {\n          config.automationRate = \"a-rate\";\n        } catch (e) {\n        } finally {\n          config.value = Math.max(0, config.minValue);\n          this.connect(config, offset + i);\n        }\n      } else if (config instanceof AudioNode) {\n        this.connect(config, offset + i);\n      } else {\n        this.requestDispatchIParamChange(name);\n      }\n    });\n    this.connect(this.module.audioContext.destination, 0, 0);\n    this.initialized = true;\n    return this;\n  }\n  setBuffer({ lock, paramsBuffer }) {\n    this.$lock = lock;\n    this.$paramsBuffer = paramsBuffer;\n  }\n  setParamsMapping(paramsMapping) {\n    return this.call(\"setParamsMapping\", paramsMapping);\n  }\n  getCompensationDelay() {\n    return this.call(\"getCompensationDelay\");\n  }\n  getParameterInfo(...parameterIdQuery) {\n    return this.call(\"getParameterInfo\", ...parameterIdQuery);\n  }\n  getParameterValues(normalized, ...parameterIdQuery) {\n    return this.call(\"getParameterValues\", normalized, ...parameterIdQuery);\n  }\n  scheduleAutomation(event) {\n    const time = event.time || this.context.currentTime;\n    const { id, normalized, value } = event.data;\n    const audioParam = this.getParam(id);\n    if (!audioParam)\n      return;\n    if (audioParam.info.type === \"float\") {\n      if (normalized)\n        audioParam.linearRampToNormalizedValueAtTime(value, time);\n      else\n        audioParam.linearRampToValueAtTime(value, time);\n    } else {\n      if (normalized)\n        audioParam.setNormalizedValueAtTime(value, time);\n      else\n        audioParam.setValueAtTime(value, time);\n    }\n  }\n  scheduleEvents(...events) {\n    events.forEach((event) => {\n      if (event.type === \"wam-automation\") {\n        this.scheduleAutomation(event);\n      }\n    });\n    this.call(\"scheduleEvents\", ...events);\n  }\n  emitEvents(...events) {\n    this.call(\"emitEvents\", ...events);\n  }\n  clearEvents() {\n    this.call(\"clearEvents\");\n  }\n  dispatchWamEvent(event) {\n    if (event.type === \"wam-automation\") {\n      this.scheduleAutomation(event);\n    } else {\n      this.dispatchEvent(new CustomEvent(event.type, { detail: event }));\n    }\n  }\n  async setParameterValues(parameterValues) {\n    Object.keys(parameterValues).forEach((parameterId) => {\n      const parameterUpdate = parameterValues[parameterId];\n      const parameter = this.parameters.get(parameterId);\n      if (!parameter)\n        return;\n      if (!parameterUpdate.normalized)\n        parameter.value = parameterUpdate.value;\n      else\n        parameter.normalizedValue = parameterUpdate.value;\n    });\n  }\n  async getState() {\n    return this.getParamsValues();\n  }\n  async setState(state) {\n    this.setParamsValues(state);\n  }\n  convertTimeToFrame(time) {\n    return Math.round(time * this.context.sampleRate);\n  }\n  convertFrameToTime(frame) {\n    return frame / this.context.sampleRate;\n  }\n  getIParamIndex(name) {\n    const i = this.internalParams.indexOf(name);\n    return i === -1 ? null : i;\n  }\n  connectIParam(name, dest, index) {\n    const offset = 1;\n    const i = this.getIParamIndex(name);\n    if (i !== null) {\n      if (dest instanceof AudioNode) {\n        if (typeof index === \"number\")\n          this.connect(dest, offset + i, index);\n        else\n          this.connect(dest, offset + i);\n      } else {\n        this.connect(dest, offset + i);\n      }\n    }\n  }\n  disconnectIParam(name, dest, index) {\n    const offset = 1;\n    const i = this.getIParamIndex(name);\n    if (i !== null) {\n      if (dest instanceof AudioNode) {\n        if (typeof index === \"number\")\n          this.disconnect(dest, offset + i, index);\n        else\n          this.disconnect(dest, offset + i);\n      } else {\n        this.disconnect(dest, offset + i);\n      }\n    }\n  }\n  getIParamValue(name) {\n    const i = this.getIParamIndex(name);\n    return i !== null ? this.$paramsBuffer[i] : null;\n  }\n  getIParamsValues() {\n    const values = {};\n    this.internalParams.forEach((name, i) => {\n      values[name] = this.$paramsBuffer[i];\n    });\n    return values;\n  }\n  getParam(name) {\n    return this.parameters.get(name) || null;\n  }\n  getParams() {\n    return Object.fromEntries(this.parameters);\n  }\n  getParamValue(name) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.value;\n  }\n  setParamValue(name, value) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return;\n    param.value = value;\n  }\n  getParamsValues() {\n    const values = {};\n    this.parameters.forEach((v, k) => {\n      values[k] = v.value;\n    });\n    return values;\n  }\n  setParamsValues(values) {\n    if (!values)\n      return;\n    Object.entries(values).forEach(([k, v]) => {\n      this.setParamValue(k, v);\n    });\n  }\n  getNormalizedParamValue(name) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.normalizedValue;\n  }\n  setNormalizedParamValue(name, value) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return;\n    param.normalizedValue = value;\n  }\n  getNormalizedParamsValues() {\n    const values = {};\n    this.parameters.forEach((v, k) => {\n      values[k] = this.getNormalizedParamValue(k);\n    });\n    return values;\n  }\n  setNormalizedParamsValues(values) {\n    if (!values)\n      return;\n    Object.entries(values).forEach(([k, v]) => {\n      this.setNormalizedParamValue(k, v);\n    });\n  }\n  setParamValueAtTime(name, value, startTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setValueAtTime(value, startTime);\n  }\n  setNormalizedParamValueAtTime(name, value, startTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setNormalizedValueAtTime(value, startTime);\n  }\n  linearRampToParamValueAtTime(name, value, endTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.linearRampToValueAtTime(value, endTime);\n  }\n  linearRampToNormalizedParamValueAtTime(name, value, endTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.linearRampToNormalizedValueAtTime(value, endTime);\n  }\n  exponentialRampToParamValueAtTime(name, value, endTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.exponentialRampToValueAtTime(value, endTime);\n  }\n  exponentialRampToNormalizedParamValueAtTime(name, value, endTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.exponentialRampToNormalizedValueAtTime(value, endTime);\n  }\n  setParamTargetAtTime(name, target, startTime, timeConstant) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setTargetAtTime(target, startTime, timeConstant);\n  }\n  setNormalizedParamTargetAtTime(name, target, startTime, timeConstant) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setNormalizedTargetAtTime(target, startTime, timeConstant);\n  }\n  setParamValueCurveAtTime(name, values, startTime, duration) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setValueCurveAtTime(values, startTime, duration);\n  }\n  setNormalizedParamValueCurveAtTime(name, values, startTime, duration) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.setNormalizedValueCurveAtTime(values, startTime, duration);\n  }\n  cancelScheduledParamValues(name, cancelTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.cancelScheduledValues(cancelTime);\n  }\n  cancelAndHoldParamAtTime(name, cancelTime) {\n    const param = this.parameters.get(name);\n    if (!param)\n      return null;\n    return param.cancelAndHoldAtTime(cancelTime);\n  }\n  connectEvents(toId, output) {\n    this.call(\"connectEvents\", toId, output);\n  }\n  disconnectEvents(toId, output) {\n    this.call(\"disconnectEvents\", toId, output);\n  }\n  async destroy() {\n    this.disconnect();\n    this.paramsUpdateCheckFnRef.forEach((ref) => {\n      if (typeof ref === \"number\")\n        window.clearTimeout(ref);\n    });\n    await this.call(\"destroy\");\n    this.port.close();\n  }\n};\n\n// src/ParamMgrFactory.js\nvar ParamMgrFactory = class {\n  static async create(module, optionsIn = {}) {\n    const { audioContext, groupId, moduleId, instanceId } = module;\n    const { paramsConfig, paramsMapping, internalParamsConfig } = new ParamMappingConfigurator(optionsIn);\n    const initialParamsValue = Object.entries(paramsConfig).reduce((currentParams, [name, { defaultValue }]) => {\n      currentParams[name] = defaultValue;\n      return currentParams;\n    }, {});\n    const serializableParamsConfig = Object.entries(paramsConfig).reduce((currentParams, [name, { id, label, type, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units }]) => {\n      currentParams[name] = { id, label, type, defaultValue, minValue, maxValue, discreteStep, exponent, choices, units };\n      return currentParams;\n    }, {});\n    await addFunctionModule_default(audioContext.audioWorklet, ParamMgrProcessor_default, moduleId, serializableParamsConfig);\n    const options = {\n      internalParamsConfig,\n      parameterData: initialParamsValue,\n      processorOptions: {\n        paramsConfig,\n        paramsMapping,\n        internalParamsMinValues: Object.values(internalParamsConfig).map((config) => Math.max(0, (config == null ? void 0 : config.minValue) || 0)),\n        internalParams: Object.keys(internalParamsConfig),\n        groupId,\n        instanceId,\n        moduleId\n      }\n    };\n    const node = new ParamMgrNode(module, options);\n    await node.initialize();\n    return node;\n  }\n};\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://synth101-wam/../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js?");

/***/ }),

/***/ "../../../node_modules/@webaudiomodules/sdk/dist/index.js":
/*!****************************************************************!*\
  !*** ../../../node_modules/@webaudiomodules/sdk/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WamNode\": () => (/* binding */ WamNode),\n/* harmony export */   \"WebAudioModule\": () => (/* binding */ WebAudioModule_default),\n/* harmony export */   \"addFunctionModule\": () => (/* binding */ addFunctionModule_default),\n/* harmony export */   \"apiVersion\": () => (/* binding */ apiVersion_default),\n/* harmony export */   \"getRingBuffer\": () => (/* binding */ RingBuffer_default),\n/* harmony export */   \"getWamArrayRingBuffer\": () => (/* binding */ WamArrayRingBuffer_default),\n/* harmony export */   \"getWamEventRingBuffer\": () => (/* binding */ WamEventRingBuffer_default),\n/* harmony export */   \"getWamParameter\": () => (/* binding */ WamParameter_default),\n/* harmony export */   \"getWamParameterInfo\": () => (/* binding */ WamParameterInfo_default),\n/* harmony export */   \"getWamParameterInterpolator\": () => (/* binding */ WamParameterInterpolator_default),\n/* harmony export */   \"getWamProcessor\": () => (/* binding */ WamProcessor_default),\n/* harmony export */   \"initializeWamEnv\": () => (/* binding */ WamEnv_default),\n/* harmony export */   \"initializeWamGroup\": () => (/* binding */ WamGroup_default),\n/* harmony export */   \"initializeWamHost\": () => (/* binding */ initializeWamHost_default)\n/* harmony export */ });\n// src/WebAudioModule.js\nvar WebAudioModule = class {\n  static get isWebAudioModuleConstructor() {\n    return true;\n  }\n  static createInstance(groupId, audioContext, initialState) {\n    return new this(groupId, audioContext).initialize(initialState);\n  }\n  constructor(groupId, audioContext) {\n    this._groupId = groupId;\n    this._audioContext = audioContext;\n    this._initialized = false;\n    this._audioNode = void 0;\n    this._timestamp = performance.now();\n    this._guiModuleUrl = void 0;\n    this._descriptorUrl = \"./descriptor.json\";\n    this._descriptor = {\n      identifier: `com.webaudiomodule.default`,\n      name: `WebAudioModule_${this.constructor.name}`,\n      vendor: \"WebAudioModuleVendor\",\n      description: \"\",\n      version: \"0.0.0\",\n      apiVersion: \"2.0.0\",\n      thumbnail: \"\",\n      keywords: [],\n      isInstrument: false,\n      website: \"\",\n      hasAudioInput: true,\n      hasAudioOutput: true,\n      hasAutomationInput: true,\n      hasAutomationOutput: true,\n      hasMidiInput: true,\n      hasMidiOutput: true,\n      hasMpeInput: true,\n      hasMpeOutput: true,\n      hasOscInput: true,\n      hasOscOutput: true,\n      hasSysexInput: true,\n      hasSysexOutput: true\n    };\n  }\n  get isWebAudioModule() {\n    return true;\n  }\n  get groupId() {\n    return this._groupId;\n  }\n  get moduleId() {\n    return this.descriptor.identifier;\n  }\n  get instanceId() {\n    return this.moduleId + this._timestamp;\n  }\n  get descriptor() {\n    return this._descriptor;\n  }\n  get identifier() {\n    return this.descriptor.identifier;\n  }\n  get name() {\n    return this.descriptor.name;\n  }\n  get vendor() {\n    return this.descriptor.vendor;\n  }\n  get audioContext() {\n    return this._audioContext;\n  }\n  get audioNode() {\n    if (!this.initialized)\n      console.warn(\"WAM should be initialized before getting the audioNode\");\n    return this._audioNode;\n  }\n  set audioNode(node) {\n    this._audioNode = node;\n  }\n  get initialized() {\n    return this._initialized;\n  }\n  set initialized(value) {\n    this._initialized = value;\n  }\n  async createAudioNode(initialState) {\n    throw new TypeError(\"createAudioNode() not provided\");\n  }\n  async initialize(state) {\n    if (!this._audioNode)\n      this.audioNode = await this.createAudioNode();\n    this.initialized = true;\n    return this;\n  }\n  async _loadGui() {\n    const url = this._guiModuleUrl;\n    if (!url)\n      throw new TypeError(\"Gui module not found\");\n    return import(\n      /* webpackIgnore: true */\n      url\n    );\n  }\n  async _loadDescriptor() {\n    const url = this._descriptorUrl;\n    if (!url)\n      throw new TypeError(\"Descriptor not found\");\n    const response = await fetch(url);\n    const descriptor = await response.json();\n    Object.assign(this._descriptor, descriptor);\n    return this._descriptor;\n  }\n  async createGui() {\n    if (!this.initialized)\n      console.warn(\"Plugin should be initialized before getting the gui\");\n    if (!this._guiModuleUrl)\n      return void 0;\n    const { createElement } = await this._loadGui();\n    return createElement(this);\n  }\n  destroyGui() {\n  }\n};\nvar WebAudioModule_default = WebAudioModule;\n\n// src/RingBuffer.js\nvar getRingBuffer = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class RingBuffer2 {\n    static getStorageForCapacity(capacity, Type) {\n      if (!Type.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass in a ArrayBuffer subclass\");\n      }\n      const bytes = 8 + (capacity + 1) * Type.BYTES_PER_ELEMENT;\n      return new SharedArrayBuffer(bytes);\n    }\n    constructor(sab, Type) {\n      if (!Type.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass a concrete typed array class as second argument\");\n      }\n      this._Type = Type;\n      this._capacity = (sab.byteLength - 8) / Type.BYTES_PER_ELEMENT;\n      this.buf = sab;\n      this.write_ptr = new Uint32Array(this.buf, 0, 1);\n      this.read_ptr = new Uint32Array(this.buf, 4, 1);\n      this.storage = new Type(this.buf, 8, this._capacity);\n    }\n    get type() {\n      return this._Type.name;\n    }\n    push(elements) {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      if ((wr + 1) % this._storageCapacity() === rd) {\n        return 0;\n      }\n      const toWrite = Math.min(this._availableWrite(rd, wr), elements.length);\n      const firstPart = Math.min(this._storageCapacity() - wr, toWrite);\n      const secondPart = toWrite - firstPart;\n      this._copy(elements, 0, this.storage, wr, firstPart);\n      this._copy(elements, firstPart, this.storage, 0, secondPart);\n      Atomics.store(this.write_ptr, 0, (wr + toWrite) % this._storageCapacity());\n      return toWrite;\n    }\n    pop(elements) {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      if (wr === rd) {\n        return 0;\n      }\n      const isArray = !Number.isInteger(elements);\n      const toRead = Math.min(this._availableRead(rd, wr), isArray ? elements.length : elements);\n      if (isArray) {\n        const firstPart = Math.min(this._storageCapacity() - rd, toRead);\n        const secondPart = toRead - firstPart;\n        this._copy(this.storage, rd, elements, 0, firstPart);\n        this._copy(this.storage, 0, elements, firstPart, secondPart);\n      }\n      Atomics.store(this.read_ptr, 0, (rd + toRead) % this._storageCapacity());\n      return toRead;\n    }\n    get empty() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return wr === rd;\n    }\n    get full() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return (wr + 1) % this._capacity !== rd;\n    }\n    get capacity() {\n      return this._capacity - 1;\n    }\n    get availableRead() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return this._availableRead(rd, wr);\n    }\n    get availableWrite() {\n      const rd = Atomics.load(this.read_ptr, 0);\n      const wr = Atomics.load(this.write_ptr, 0);\n      return this._availableWrite(rd, wr);\n    }\n    _availableRead(rd, wr) {\n      if (wr > rd) {\n        return wr - rd;\n      }\n      return wr + this._storageCapacity() - rd;\n    }\n    _availableWrite(rd, wr) {\n      let rv = rd - wr - 1;\n      if (wr >= rd) {\n        rv += this._storageCapacity();\n      }\n      return rv;\n    }\n    _storageCapacity() {\n      return this._capacity;\n    }\n    _copy(input, offsetInput, output, offsetOutput, size) {\n      for (let i = 0; i < size; i++) {\n        output[offsetOutput + i] = input[offsetInput + i];\n      }\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.RingBuffer)\n      ModuleScope.RingBuffer = RingBuffer2;\n  }\n  return RingBuffer2;\n};\nvar RingBuffer_default = getRingBuffer;\n\n// src/WamArrayRingBuffer.js\nvar getWamArrayRingBuffer = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamArrayRingBuffer {\n    static DefaultArrayCapacity = 2;\n    static getStorageForEventCapacity(RingBuffer2, arrayLength, arrayType, maxArrayCapacity = void 0) {\n      if (maxArrayCapacity === void 0)\n        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n      else\n        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n      if (!arrayType.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass in a ArrayBuffer subclass\");\n      }\n      const capacity = arrayLength * maxArrayCapacity;\n      return RingBuffer2.getStorageForCapacity(capacity, arrayType);\n    }\n    constructor(RingBuffer2, sab, arrayLength, arrayType, maxArrayCapacity = void 0) {\n      if (!arrayType.BYTES_PER_ELEMENT) {\n        throw new Error(\"Pass in a ArrayBuffer subclass\");\n      }\n      this._arrayLength = arrayLength;\n      this._arrayType = arrayType;\n      this._arrayElementSizeBytes = arrayType.BYTES_PER_ELEMENT;\n      this._arraySizeBytes = this._arrayLength * this._arrayElementSizeBytes;\n      this._sab = sab;\n      if (maxArrayCapacity === void 0)\n        maxArrayCapacity = WamArrayRingBuffer.DefaultArrayCapacity;\n      else\n        maxArrayCapacity = Math.max(maxArrayCapacity, WamArrayRingBuffer.DefaultArrayCapacity);\n      this._arrayArray = new arrayType(this._arrayLength);\n      this._rb = new RingBuffer2(this._sab, arrayType);\n    }\n    write(array) {\n      if (array.length !== this._arrayLength)\n        return false;\n      const elementsAvailable = this._rb.availableWrite;\n      if (elementsAvailable < this._arrayLength)\n        return false;\n      let success = true;\n      const elementsWritten = this._rb.push(array);\n      if (elementsWritten != this._arrayLength)\n        success = false;\n      return success;\n    }\n    read(array, newest) {\n      if (array.length !== this._arrayLength)\n        return false;\n      const elementsAvailable = this._rb.availableRead;\n      if (elementsAvailable < this._arrayLength)\n        return false;\n      if (newest && elementsAvailable > this._arrayLength)\n        this._rb.pop(elementsAvailable - this._arrayLength);\n      let success = false;\n      const elementsRead = this._rb.pop(array);\n      if (elementsRead === this._arrayLength)\n        success = true;\n      return success;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamArrayRingBuffer)\n      ModuleScope.WamArrayRingBuffer = WamArrayRingBuffer;\n  }\n  return WamArrayRingBuffer;\n};\nvar WamArrayRingBuffer_default = getWamArrayRingBuffer;\n\n// src/WamEnv.js\nvar initializeWamEnv = (apiVersion) => {\n  const audioWorkletGlobalScope = globalThis;\n  if (audioWorkletGlobalScope.AudioWorkletProcessor && audioWorkletGlobalScope.webAudioModules)\n    return;\n  const moduleScopes = /* @__PURE__ */ new Map();\n  const groups = /* @__PURE__ */ new Map();\n  class WamEnv {\n    constructor() {\n    }\n    get apiVersion() {\n      return apiVersion;\n    }\n    getModuleScope(moduleId) {\n      if (!moduleScopes.has(moduleId))\n        moduleScopes.set(moduleId, {});\n      return moduleScopes.get(moduleId);\n    }\n    getGroup(groupId, groupKey) {\n      const group = groups.get(groupId);\n      if (group.validate(groupKey))\n        return group;\n      else\n        throw \"Invalid key\";\n    }\n    addGroup(group) {\n      if (!groups.has(group.groupId))\n        groups.set(group.groupId, group);\n    }\n    removeGroup(group) {\n      groups.delete(group.groupId);\n    }\n    addWam(wam) {\n      const group = groups.get(wam.groupId);\n      group.addWam(wam);\n    }\n    removeWam(wam) {\n      const group = groups.get(wam.groupId);\n      group.removeWam(wam);\n    }\n    connectEvents(groupId, fromId, toId, output = 0) {\n      const group = groups.get(groupId);\n      group.connectEvents(fromId, toId, output);\n    }\n    disconnectEvents(groupId, fromId, toId, output) {\n      const group = groups.get(groupId);\n      group.disconnectEvents(fromId, toId, output);\n    }\n    emitEvents(from, ...events) {\n      const group = groups.get(from.groupId);\n      group.emitEvents(from, ...events);\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    if (!audioWorkletGlobalScope.webAudioModules)\n      audioWorkletGlobalScope.webAudioModules = new WamEnv();\n  }\n};\nvar WamEnv_default = initializeWamEnv;\n\n// src/WamGroup.js\nvar initializeWamGroup = (groupId, groupKey) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamGroup {\n    constructor(groupId2, groupKey2) {\n      this._groupId = groupId2;\n      this._validate = (key) => {\n        return key == groupKey2;\n      };\n      this._processors = /* @__PURE__ */ new Map();\n      this._eventGraph = /* @__PURE__ */ new Map();\n    }\n    get groupId() {\n      return this._groupId;\n    }\n    get processors() {\n      return this._processors;\n    }\n    get eventGraph() {\n      return this._eventGraph;\n    }\n    validate(groupKey2) {\n      return this._validate(groupKey2);\n    }\n    addWam(wam) {\n      this._processors.set(wam.instanceId, wam);\n    }\n    removeWam(wam) {\n      if (this._eventGraph.has(wam))\n        this._eventGraph.delete(wam);\n      this._eventGraph.forEach((outputMap) => {\n        outputMap.forEach((set) => {\n          if (set && set.has(wam))\n            set.delete(wam);\n        });\n      });\n      this._processors.delete(wam.instanceId);\n    }\n    connectEvents(fromId, toId, output) {\n      const from = this._processors.get(fromId);\n      const to = this._processors.get(toId);\n      let outputMap;\n      if (this._eventGraph.has(from)) {\n        outputMap = this._eventGraph.get(from);\n      } else {\n        outputMap = [];\n        this._eventGraph.set(from, outputMap);\n      }\n      if (outputMap[output]) {\n        outputMap[output].add(to);\n      } else {\n        const set = /* @__PURE__ */ new Set();\n        set.add(to);\n        outputMap[output] = set;\n      }\n    }\n    disconnectEvents(fromId, toId, output) {\n      const from = this._processors.get(fromId);\n      if (!this._eventGraph.has(from))\n        return;\n      const outputMap = this._eventGraph.get(from);\n      if (typeof toId === \"undefined\") {\n        outputMap.forEach((set) => {\n          if (set)\n            set.clear();\n        });\n        return;\n      }\n      const to = this._processors.get(toId);\n      if (typeof output === \"undefined\") {\n        outputMap.forEach((set) => {\n          if (set)\n            set.delete(to);\n        });\n        return;\n      }\n      if (!outputMap[output])\n        return;\n      outputMap[output].delete(to);\n    }\n    emitEvents(from, ...events) {\n      if (!this._eventGraph.has(from))\n        return;\n      const downstream = this._eventGraph.get(from);\n      downstream.forEach((set) => {\n        if (set)\n          set.forEach((wam) => wam.scheduleEvents(...events));\n      });\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    audioWorkletGlobalScope.webAudioModules.addGroup(new WamGroup(groupId, groupKey));\n  }\n};\nvar WamGroup_default = initializeWamGroup;\n\n// src/WamEventRingBuffer.js\nvar getWamEventRingBuffer = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamEventRingBuffer2 {\n    static DefaultExtraBytesPerEvent = 64;\n    static WamEventBaseBytes = 4 + 1 + 8;\n    static WamAutomationEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 2 + 8 + 1;\n    static WamTransportEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4 + 8 + 8 + 1 + 1 + 1;\n    static WamMidiEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 1 + 1 + 1;\n    static WamBinaryEventBytes = WamEventRingBuffer2.WamEventBaseBytes + 4;\n    static getStorageForEventCapacity(RingBuffer2, eventCapacity, maxBytesPerEvent = void 0) {\n      if (maxBytesPerEvent === void 0)\n        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n      else\n        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n      const capacity = (Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent) * eventCapacity;\n      return RingBuffer2.getStorageForCapacity(capacity, Uint8Array);\n    }\n    constructor(RingBuffer2, sab, parameterIds, maxBytesPerEvent = void 0) {\n      this._eventSizeBytes = {};\n      this._encodeEventType = {};\n      this._decodeEventType = {};\n      const wamEventTypes = [\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\", \"wam-info\"];\n      wamEventTypes.forEach((type, encodedType) => {\n        let byteSize = 0;\n        switch (type) {\n          case \"wam-automation\":\n            byteSize = WamEventRingBuffer2.WamAutomationEventBytes;\n            break;\n          case \"wam-transport\":\n            byteSize = WamEventRingBuffer2.WamTransportEventBytes;\n            break;\n          case \"wam-mpe\":\n          case \"wam-midi\":\n            byteSize = WamEventRingBuffer2.WamMidiEventBytes;\n            break;\n          case \"wam-osc\":\n          case \"wam-sysex\":\n          case \"wam-info\":\n            byteSize = WamEventRingBuffer2.WamBinaryEventBytes;\n            break;\n          default:\n            break;\n        }\n        this._eventSizeBytes[type] = byteSize;\n        this._encodeEventType[type] = encodedType;\n        this._decodeEventType[encodedType] = type;\n      });\n      this._parameterCode = 0;\n      this._parameterCodes = {};\n      this._encodeParameterId = {};\n      this._decodeParameterId = {};\n      this.setParameterIds(parameterIds);\n      this._sab = sab;\n      if (maxBytesPerEvent === void 0)\n        maxBytesPerEvent = WamEventRingBuffer2.DefaultExtraBytesPerEvent;\n      else\n        maxBytesPerEvent = Math.max(maxBytesPerEvent, WamEventRingBuffer2.DefaultExtraBytesPerEvent);\n      this._eventBytesAvailable = Math.max(WamEventRingBuffer2.WamAutomationEventBytes, WamEventRingBuffer2.WamTransportEventBytes, WamEventRingBuffer2.WamMidiEventBytes, WamEventRingBuffer2.WamBinaryEventBytes) + maxBytesPerEvent;\n      this._eventBytes = new ArrayBuffer(this._eventBytesAvailable);\n      this._eventBytesView = new DataView(this._eventBytes);\n      this._rb = new RingBuffer2(this._sab, Uint8Array);\n      this._eventSizeArray = new Uint8Array(this._eventBytes, 0, 4);\n      this._eventSizeView = new DataView(this._eventBytes, 0, 4);\n    }\n    _writeHeader(byteSize, type, time) {\n      let byteOffset = 0;\n      this._eventBytesView.setUint32(byteOffset, byteSize);\n      byteOffset += 4;\n      this._eventBytesView.setUint8(byteOffset, this._encodeEventType[type]);\n      byteOffset += 1;\n      this._eventBytesView.setFloat64(byteOffset, Number.isFinite(time) ? time : -1);\n      byteOffset += 8;\n      return byteOffset;\n    }\n    _encode(event) {\n      let byteOffset = 0;\n      const { type, time } = event;\n      switch (event.type) {\n        case \"wam-automation\":\n          {\n            if (!(event.data.id in this._encodeParameterId))\n              break;\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize, type, time);\n            const { data } = event;\n            const encodedParameterId = this._encodeParameterId[data.id];\n            const { value, normalized } = data;\n            this._eventBytesView.setUint16(byteOffset, encodedParameterId);\n            byteOffset += 2;\n            this._eventBytesView.setFloat64(byteOffset, value);\n            byteOffset += 8;\n            this._eventBytesView.setUint8(byteOffset, normalized ? 1 : 0);\n            byteOffset += 1;\n          }\n          break;\n        case \"wam-transport\":\n          {\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize, type, time);\n            const { data } = event;\n            const {\n              currentBar,\n              currentBarStarted,\n              tempo,\n              timeSigNumerator,\n              timeSigDenominator,\n              playing\n            } = data;\n            this._eventBytesView.setUint32(byteOffset, currentBar);\n            byteOffset += 4;\n            this._eventBytesView.setFloat64(byteOffset, currentBarStarted);\n            byteOffset += 8;\n            this._eventBytesView.setFloat64(byteOffset, tempo);\n            byteOffset += 8;\n            this._eventBytesView.setUint8(byteOffset, timeSigNumerator);\n            byteOffset += 1;\n            this._eventBytesView.setUint8(byteOffset, timeSigDenominator);\n            byteOffset += 1;\n            this._eventBytesView.setUint8(byteOffset, playing ? 1 : 0);\n            byteOffset += 1;\n          }\n          break;\n        case \"wam-mpe\":\n        case \"wam-midi\":\n          {\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize, type, time);\n            const { data } = event;\n            const { bytes } = data;\n            let b = 0;\n            while (b < 3) {\n              this._eventBytesView.setUint8(byteOffset, bytes[b]);\n              byteOffset += 1;\n              b++;\n            }\n          }\n          break;\n        case \"wam-osc\":\n        case \"wam-sysex\":\n        case \"wam-info\":\n          {\n            let bytes = null;\n            if (event.type === \"wam-info\") {\n              const { data } = event;\n              bytes = new TextEncoder().encode(data.instanceId);\n            } else {\n              const { data } = event;\n              bytes = data.bytes;\n            }\n            const numBytes = bytes.length;\n            const byteSize = this._eventSizeBytes[type];\n            byteOffset = this._writeHeader(byteSize + numBytes, type, time);\n            this._eventBytesView.setUint32(byteOffset, numBytes);\n            byteOffset += 4;\n            const bytesRequired = byteOffset + numBytes;\n            if (bytesRequired > this._eventBytesAvailable)\n              console.error(`Event requires ${bytesRequired} bytes but only ${this._eventBytesAvailable} have been allocated!`);\n            const buffer = new Uint8Array(this._eventBytes, byteOffset, numBytes);\n            buffer.set(bytes);\n            byteOffset += numBytes;\n          }\n          break;\n        default:\n          break;\n      }\n      return new Uint8Array(this._eventBytes, 0, byteOffset);\n    }\n    _decode() {\n      let byteOffset = 0;\n      const type = this._decodeEventType[this._eventBytesView.getUint8(byteOffset)];\n      byteOffset += 1;\n      let time = this._eventBytesView.getFloat64(byteOffset);\n      if (time === -1)\n        time = void 0;\n      byteOffset += 8;\n      switch (type) {\n        case \"wam-automation\": {\n          const encodedParameterId = this._eventBytesView.getUint16(byteOffset);\n          byteOffset += 2;\n          const value = this._eventBytesView.getFloat64(byteOffset);\n          byteOffset += 8;\n          const normalized = !!this._eventBytesView.getUint8(byteOffset);\n          byteOffset += 1;\n          if (!(encodedParameterId in this._decodeParameterId))\n            break;\n          const id = this._decodeParameterId[encodedParameterId];\n          const event = {\n            type,\n            time,\n            data: {\n              id,\n              value,\n              normalized\n            }\n          };\n          return event;\n        }\n        case \"wam-transport\": {\n          const currentBar = this._eventBytesView.getUint32(byteOffset);\n          byteOffset += 4;\n          const currentBarStarted = this._eventBytesView.getFloat64(byteOffset);\n          byteOffset += 8;\n          const tempo = this._eventBytesView.getFloat64(byteOffset);\n          byteOffset += 8;\n          const timeSigNumerator = this._eventBytesView.getUint8(byteOffset);\n          byteOffset += 1;\n          const timeSigDenominator = this._eventBytesView.getUint8(byteOffset);\n          byteOffset += 1;\n          const playing = this._eventBytesView.getUint8(byteOffset) == 1;\n          byteOffset += 1;\n          const event = {\n            type,\n            time,\n            data: {\n              currentBar,\n              currentBarStarted,\n              tempo,\n              timeSigNumerator,\n              timeSigDenominator,\n              playing\n            }\n          };\n          return event;\n        }\n        case \"wam-mpe\":\n        case \"wam-midi\": {\n          const bytes = [0, 0, 0];\n          let b = 0;\n          while (b < 3) {\n            bytes[b] = this._eventBytesView.getUint8(byteOffset);\n            byteOffset += 1;\n            b++;\n          }\n          const event = {\n            type,\n            time,\n            data: { bytes }\n          };\n          return event;\n        }\n        case \"wam-osc\":\n        case \"wam-sysex\":\n        case \"wam-info\": {\n          const numBytes = this._eventBytesView.getUint32(byteOffset);\n          byteOffset += 4;\n          const bytes = new Uint8Array(numBytes);\n          bytes.set(new Uint8Array(this._eventBytes, byteOffset, numBytes));\n          byteOffset += numBytes;\n          if (type === \"wam-info\") {\n            const instanceId = new TextDecoder().decode(bytes);\n            const data = { instanceId };\n            return { type, time, data };\n          } else {\n            const data = { bytes };\n            return { type, time, data };\n          }\n        }\n        default:\n          break;\n      }\n      return false;\n    }\n    write(...events) {\n      const numEvents = events.length;\n      let bytesAvailable = this._rb.availableWrite;\n      let numSkipped = 0;\n      let i = 0;\n      while (i < numEvents) {\n        const event = events[i];\n        const bytes = this._encode(event);\n        const eventSizeBytes = bytes.byteLength;\n        let bytesWritten = 0;\n        if (bytesAvailable >= eventSizeBytes) {\n          if (eventSizeBytes === 0)\n            numSkipped++;\n          else\n            bytesWritten = this._rb.push(bytes);\n        } else\n          break;\n        bytesAvailable -= bytesWritten;\n        i++;\n      }\n      return i - numSkipped;\n    }\n    read() {\n      if (this._rb.empty)\n        return [];\n      const events = [];\n      let bytesAvailable = this._rb.availableRead;\n      let bytesRead = 0;\n      while (bytesAvailable > 0) {\n        bytesRead = this._rb.pop(this._eventSizeArray);\n        bytesAvailable -= bytesRead;\n        const eventSizeBytes = this._eventSizeView.getUint32(0);\n        const eventBytes = new Uint8Array(this._eventBytes, 0, eventSizeBytes - 4);\n        bytesRead = this._rb.pop(eventBytes);\n        bytesAvailable -= bytesRead;\n        const decodedEvent = this._decode();\n        if (decodedEvent)\n          events.push(decodedEvent);\n      }\n      return events;\n    }\n    setParameterIds(parameterIds) {\n      this._encodeParameterId = {};\n      this._decodeParameterId = {};\n      parameterIds.forEach((parameterId) => {\n        let parameterCode = -1;\n        if (parameterId in this._parameterCodes)\n          parameterCode = this._parameterCodes[parameterId];\n        else {\n          parameterCode = this._generateParameterCode();\n          this._parameterCodes[parameterId] = parameterCode;\n        }\n        this._encodeParameterId[parameterId] = parameterCode;\n        this._decodeParameterId[parameterCode] = parameterId;\n      });\n    }\n    _generateParameterCode() {\n      if (this._parameterCode > 65535)\n        throw Error(\"Too many parameters have been registered!\");\n      return this._parameterCode++;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamEventRingBuffer)\n      ModuleScope.WamEventRingBuffer = WamEventRingBuffer2;\n  }\n  return WamEventRingBuffer2;\n};\nvar WamEventRingBuffer_default = getWamEventRingBuffer;\n\n// src/addFunctionModule.js\nvar addFunctionModule = (audioWorklet, processorFunction, ...injection) => {\n  const text = `(${processorFunction.toString()})(${injection.map((s) => JSON.stringify(s)).join(\", \")});`;\n  const url = URL.createObjectURL(new Blob([text], { type: \"text/javascript\" }));\n  return audioWorklet.addModule(url);\n};\nvar addFunctionModule_default = addFunctionModule;\n\n// src/WamParameter.js\nvar getWamParameter = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  class WamParameter {\n    constructor(info) {\n      this.info = info;\n      this._value = info.defaultValue;\n    }\n    set value(value) {\n      this._value = value;\n    }\n    get value() {\n      return this._value;\n    }\n    set normalizedValue(valueNorm) {\n      this.value = this.info.denormalize(valueNorm);\n    }\n    get normalizedValue() {\n      return this.info.normalize(this.value);\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameter)\n      ModuleScope.WamParameter = WamParameter;\n  }\n  return WamParameter;\n};\nvar WamParameter_default = getWamParameter;\n\n// src/WamParameterInfo.js\nvar getWamParameterInfo = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const normExp = (x, e) => e === 0 ? x : x ** 1.5 ** -e;\n  const denormExp = (x, e) => e === 0 ? x : x ** 1.5 ** e;\n  const normalize = (x, min, max, e = 0) => min === 0 && max === 1 ? normExp(x, e) : normExp((x - min) / (max - min) || 0, e);\n  const denormalize = (x, min, max, e = 0) => min === 0 && max === 1 ? denormExp(x, e) : denormExp(x, e) * (max - min) + min;\n  const inRange = (x, min, max) => x >= min && x <= max;\n  class WamParameterInfo {\n    constructor(id, config = {}) {\n      let {\n        type,\n        label,\n        defaultValue,\n        minValue,\n        maxValue,\n        discreteStep,\n        exponent,\n        choices,\n        units\n      } = config;\n      if (type === void 0)\n        type = \"float\";\n      if (label === void 0)\n        label = \"\";\n      if (defaultValue === void 0)\n        defaultValue = 0;\n      if (choices === void 0)\n        choices = [];\n      if (type === \"boolean\" || type === \"choice\") {\n        discreteStep = 1;\n        minValue = 0;\n        if (choices.length)\n          maxValue = choices.length - 1;\n        else\n          maxValue = 1;\n      } else {\n        if (minValue === void 0)\n          minValue = 0;\n        if (maxValue === void 0)\n          maxValue = 1;\n        if (discreteStep === void 0)\n          discreteStep = 0;\n        if (exponent === void 0)\n          exponent = 0;\n        if (units === void 0)\n          units = \"\";\n      }\n      const errBase = `Param config error | ${id}: `;\n      if (minValue >= maxValue)\n        throw Error(errBase.concat(\"minValue must be less than maxValue\"));\n      if (!inRange(defaultValue, minValue, maxValue))\n        throw Error(errBase.concat(\"defaultValue out of range\"));\n      if (discreteStep % 1 || discreteStep < 0) {\n        throw Error(errBase.concat(\"discreteStep must be a non-negative integer\"));\n      } else if (discreteStep > 0 && (minValue % 1 || maxValue % 1 || defaultValue % 1)) {\n        throw Error(errBase.concat(\"non-zero discreteStep requires integer minValue, maxValue, and defaultValue\"));\n      }\n      if (type === \"choice\" && !choices.length) {\n        throw Error(errBase.concat(\"choice type parameter requires list of strings in choices\"));\n      }\n      this.id = id;\n      this.label = label;\n      this.type = type;\n      this.defaultValue = defaultValue;\n      this.minValue = minValue;\n      this.maxValue = maxValue;\n      this.discreteStep = discreteStep;\n      this.exponent = exponent;\n      this.choices = choices;\n      this.units = units;\n    }\n    normalize(value) {\n      return normalize(value, this.minValue, this.maxValue, this.exponent);\n    }\n    denormalize(valueNorm) {\n      return denormalize(valueNorm, this.minValue, this.maxValue, this.exponent);\n    }\n    valueString(value) {\n      if (this.choices)\n        return this.choices[value];\n      if (this.units !== \"\")\n        return `${value} ${this.units}`;\n      return `${value}`;\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameterInfo)\n      ModuleScope.WamParameterInfo = WamParameterInfo;\n  }\n  return WamParameterInfo;\n};\nvar WamParameterInfo_default = getWamParameterInfo;\n\n// src/WamParameterInterpolator.js\nvar getWamParameterInterpolator = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const samplesPerQuantum = 128;\n  const nullTableKey = \"0_0\";\n  class WamParameterInterpolator {\n    static _tables;\n    static _tableReferences;\n    constructor(info, samplesPerInterpolation, skew = 0) {\n      if (!WamParameterInterpolator._tables) {\n        WamParameterInterpolator._tables = { nullTableKey: new Float32Array(0) };\n        WamParameterInterpolator._tableReferences = { nullTableKey: [] };\n      }\n      this.info = info;\n      this.values = new Float32Array(samplesPerQuantum);\n      this._tableKey = nullTableKey;\n      this._table = WamParameterInterpolator._tables[this._tableKey];\n      this._skew = 2;\n      const { discreteStep } = info;\n      this._discrete = !!discreteStep;\n      this._N = this._discrete ? 0 : samplesPerInterpolation;\n      this._n = 0;\n      this._startValue = info.defaultValue;\n      this._endValue = info.defaultValue;\n      this._currentValue = info.defaultValue;\n      this._deltaValue = 0;\n      this._inverted = false;\n      this._changed = true;\n      this._filled = 0;\n      if (!this._discrete)\n        this.setSkew(skew);\n      else\n        this._skew = 0;\n      this.setStartValue(this._startValue);\n    }\n    _removeTableReference(oldKey) {\n      if (oldKey === nullTableKey)\n        return;\n      const { id } = this.info;\n      const references = WamParameterInterpolator._tableReferences[oldKey];\n      if (references) {\n        const index = references.indexOf(id);\n        if (index !== -1)\n          references.splice(index, 1);\n        if (references.length === 0) {\n          delete WamParameterInterpolator._tables[oldKey];\n          delete WamParameterInterpolator._tableReferences[oldKey];\n        }\n      }\n    }\n    setSkew(skew) {\n      if (this._skew === skew || this._discrete)\n        return;\n      if (skew < -1 || skew > 1)\n        throw Error(\"skew must be in range [-1.0, 1.0]\");\n      const newKey = [this._N, skew].join(\"_\");\n      const oldKey = this._tableKey;\n      const { id } = this.info;\n      if (newKey === oldKey)\n        return;\n      if (WamParameterInterpolator._tables[newKey]) {\n        const references = WamParameterInterpolator._tableReferences[newKey];\n        if (references)\n          references.push(id);\n        else\n          WamParameterInterpolator._tableReferences[newKey] = [id];\n      } else {\n        let e = Math.abs(skew);\n        e = Math.pow(3 - e, e * (e + 2));\n        const linear = e === 1;\n        const N = this._N;\n        const table = new Float32Array(N + 1);\n        if (linear)\n          for (let n = 0; n <= N; ++n)\n            table[n] = n / N;\n        else\n          for (let n = 0; n <= N; ++n)\n            table[n] = (n / N) ** e;\n        WamParameterInterpolator._tables[newKey] = table;\n        WamParameterInterpolator._tableReferences[newKey] = [id];\n      }\n      this._removeTableReference(oldKey);\n      this._skew = skew;\n      this._tableKey = newKey;\n      this._table = WamParameterInterpolator._tables[this._tableKey];\n    }\n    setStartValue(value, fill = true) {\n      this._n = this._N;\n      this._startValue = value;\n      this._endValue = value;\n      this._currentValue = value;\n      this._deltaValue = 0;\n      this._inverted = false;\n      if (fill) {\n        this.values.fill(value);\n        this._changed = true;\n        this._filled = this.values.length;\n      } else {\n        this._changed = false;\n        this._filled = 0;\n      }\n    }\n    setEndValue(value) {\n      if (value === this._endValue)\n        return;\n      this._n = 0;\n      this._startValue = this._currentValue;\n      this._endValue = value;\n      this._deltaValue = this._endValue - this._startValue;\n      this._inverted = this._deltaValue > 0 && this._skew >= 0 || this._deltaValue <= 0 && this._skew < 0;\n      this._changed = false;\n      this._filled = 0;\n    }\n    process(startSample, endSample) {\n      if (this.done)\n        return;\n      const length = endSample - startSample;\n      let fill = 0;\n      const change = this._N - this._n;\n      if (this._discrete || !change)\n        fill = length;\n      else {\n        if (change < length) {\n          fill = Math.min(length - change, samplesPerQuantum);\n          endSample -= fill;\n        }\n        if (endSample > startSample) {\n          if (this._inverted) {\n            for (let i = startSample; i < endSample; ++i) {\n              const tableValue = 1 - this._table[this._N - ++this._n];\n              this.values[i] = this._startValue + tableValue * this._deltaValue;\n            }\n          } else {\n            for (let i = startSample; i < endSample; ++i) {\n              const tableValue = this._table[++this._n];\n              this.values[i] = this._startValue + tableValue * this._deltaValue;\n            }\n          }\n        }\n        if (fill > 0) {\n          startSample = endSample;\n          endSample += fill;\n        }\n      }\n      if (fill > 0) {\n        this.values.fill(this._endValue, startSample, endSample);\n        this._filled += fill;\n      }\n      this._currentValue = this.values[endSample - 1];\n      if (this._n === this._N) {\n        if (!this._changed)\n          this._changed = true;\n        else if (this._filled >= this.values.length) {\n          this.setStartValue(this._endValue, false);\n          this._changed = true;\n          this._filled = this.values.length;\n        }\n      }\n    }\n    get done() {\n      return this._changed && this._filled === this.values.length;\n    }\n    is(value) {\n      return this._endValue === value && this.done;\n    }\n    destroy() {\n      this._removeTableReference(this._tableKey);\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n    if (!ModuleScope.WamParameterInterpolator)\n      ModuleScope.WamParameterInterpolator = WamParameterInterpolator;\n  }\n  return WamParameterInterpolator;\n};\nvar WamParameterInterpolator_default = getWamParameterInterpolator;\n\n// src/WamProcessor.js\nvar getWamProcessor = (moduleId) => {\n  const audioWorkletGlobalScope = globalThis;\n  const {\n    AudioWorkletProcessor,\n    webAudioModules\n  } = audioWorkletGlobalScope;\n  const ModuleScope = audioWorkletGlobalScope.webAudioModules.getModuleScope(moduleId);\n  const {\n    RingBuffer: RingBuffer2,\n    WamEventRingBuffer: WamEventRingBuffer2,\n    WamParameter,\n    WamParameterInterpolator\n  } = ModuleScope;\n  class WamProcessor extends AudioWorkletProcessor {\n    constructor(options) {\n      super();\n      const {\n        groupId,\n        moduleId: moduleId2,\n        instanceId,\n        useSab\n      } = options.processorOptions;\n      if (!moduleId2)\n        throw Error(\"must provide moduleId argument in processorOptions!\");\n      if (!instanceId)\n        throw Error(\"must provide instanceId argument in processorOptions!\");\n      this.groupId = groupId;\n      this.moduleId = moduleId2;\n      this.instanceId = instanceId;\n      this._samplesPerQuantum = 128;\n      this._compensationDelay = 0;\n      this._parameterInfo = {};\n      this._parameterState = {};\n      this._parameterInterpolators = {};\n      this._eventQueue = [];\n      this._pendingResponses = {};\n      this._useSab = !!useSab && !!globalThis.SharedArrayBuffer;\n      this._eventSabReady = false;\n      this._audioToMainEventSab = null;\n      this._mainToAudioEventSab = null;\n      this._eventWriter = null;\n      this._eventReader = null;\n      this._initialized = false;\n      this._destroyed = false;\n      webAudioModules.addWam(this);\n      this.port.onmessage = this._onMessage.bind(this);\n      if (this._useSab)\n        this._configureSab();\n    }\n    getCompensationDelay() {\n      return this._compensationDelay;\n    }\n    scheduleEvents(...events) {\n      let i = 0;\n      while (i < events.length) {\n        this._eventQueue.push({ id: 0, event: events[i] });\n        i++;\n      }\n      this._eventQueue.sort((a, b) => a.event.time - b.event.time);\n    }\n    emitEvents(...events) {\n      webAudioModules.emitEvents(this, ...events);\n    }\n    clearEvents() {\n      this._eventQueue = [];\n    }\n    process(inputs, outputs, parameters) {\n      if (!this._initialized)\n        return true;\n      if (this._destroyed)\n        return false;\n      if (this._eventSabReady)\n        this.scheduleEvents(...this._eventReader.read());\n      const processingSlices = this._getProcessingSlices();\n      let i = 0;\n      while (i < processingSlices.length) {\n        const { range, events } = processingSlices[i];\n        const [startSample, endSample] = range;\n        let j = 0;\n        while (j < events.length) {\n          this._processEvent(events[j]);\n          j++;\n        }\n        this._interpolateParameterValues(startSample, endSample);\n        this._process(startSample, endSample, inputs, outputs, parameters);\n        i++;\n      }\n      return true;\n    }\n    destroy() {\n      this._destroyed = true;\n      this.port.close();\n      webAudioModules.removeWam(this);\n    }\n    _generateWamParameterInfo() {\n      return {};\n    }\n    _initialize() {\n      this._parameterState = {};\n      this._parameterInterpolators = {};\n      this._parameterInfo = this._generateWamParameterInfo();\n      Object.keys(this._parameterInfo).forEach((parameterId) => {\n        const info = this._parameterInfo[parameterId];\n        this._parameterState[parameterId] = new WamParameter(this._parameterInfo[parameterId]);\n        this._parameterInterpolators[parameterId] = new WamParameterInterpolator(info, 256);\n      });\n    }\n    _configureSab() {\n      const eventCapacity = 2 ** 10;\n      const parameterIds = Object.keys(this._parameterInfo);\n      if (this._eventSabReady) {\n        this._eventWriter.setParameterIds(parameterIds);\n        this._eventReader.setParameterIds(parameterIds);\n      }\n      this.port.postMessage({ eventSab: { eventCapacity, parameterIds } });\n    }\n    async _onMessage(message) {\n      if (message.data.request) {\n        const {\n          id,\n          request,\n          content\n        } = message.data;\n        const response = { id, response: request };\n        const requestComponents = request.split(\"/\");\n        const verb = requestComponents[0];\n        const noun = requestComponents[1];\n        response.content = \"error\";\n        if (verb === \"get\") {\n          if (noun === \"parameterInfo\") {\n            let { parameterIds } = content;\n            if (!parameterIds.length)\n              parameterIds = Object.keys(this._parameterInfo);\n            const parameterInfo = {};\n            let i = 0;\n            while (i < parameterIds.length) {\n              const parameterId = parameterIds[i];\n              parameterInfo[parameterId] = this._parameterInfo[parameterId];\n              i++;\n            }\n            response.content = parameterInfo;\n          } else if (noun === \"parameterValues\") {\n            let { normalized, parameterIds } = content;\n            response.content = this._getParameterValues(normalized, parameterIds);\n          } else if (noun === \"state\") {\n            response.content = this._getState();\n          } else if (noun === \"compensationDelay\") {\n            response.content = this.getCompensationDelay();\n          }\n        } else if (verb === \"set\") {\n          if (noun === \"parameterValues\") {\n            const { parameterValues } = content;\n            this._setParameterValues(parameterValues, true);\n            delete response.content;\n          } else if (noun === \"state\") {\n            const { state } = content;\n            this._setState(state);\n            delete response.content;\n          }\n        } else if (verb === \"add\") {\n          if (noun === \"event\") {\n            const { event } = content;\n            this._eventQueue.push({ id, event });\n            return;\n          }\n        } else if (verb === \"remove\") {\n          if (noun === \"events\") {\n            const ids = this._eventQueue.map((queued) => queued.id);\n            this.clearEvents();\n            response.content = ids;\n          }\n        } else if (verb === \"connect\") {\n          if (noun === \"events\") {\n            const { wamInstanceId, output } = content;\n            this._connectEvents(wamInstanceId, output);\n            delete response.content;\n          }\n        } else if (verb === \"disconnect\") {\n          if (noun === \"events\") {\n            const { wamInstanceId, output } = content;\n            this._disconnectEvents(wamInstanceId, output);\n            delete response.content;\n          }\n        } else if (verb === \"initialize\") {\n          if (noun === \"processor\") {\n            this._initialize();\n            this._initialized = true;\n            delete response.content;\n          } else if (noun === \"eventSab\") {\n            const { mainToAudioEventSab, audioToMainEventSab } = content;\n            this._audioToMainEventSab = audioToMainEventSab;\n            this._mainToAudioEventSab = mainToAudioEventSab;\n            const parameterIds = Object.keys(this._parameterInfo);\n            this._eventWriter = new WamEventRingBuffer2(RingBuffer2, this._audioToMainEventSab, parameterIds);\n            this._eventReader = new WamEventRingBuffer2(RingBuffer2, this._mainToAudioEventSab, parameterIds);\n            this._eventSabReady = true;\n            delete response.content;\n          }\n        }\n        this.port.postMessage(response);\n      } else if (message.data.destroy) {\n        this.destroy();\n      }\n    }\n    _onTransport(transportData) {\n      console.error(\"_onTransport not implemented!\");\n    }\n    _onMidi(midiData) {\n      console.error(\"_onMidi not implemented!\");\n    }\n    _onSysex(sysexData) {\n      console.error(\"_onMidi not implemented!\");\n    }\n    _onMpe(mpeData) {\n      console.error(\"_onMpe not implemented!\");\n    }\n    _onOsc(oscData) {\n      console.error(\"_onOsc not implemented!\");\n    }\n    _setState(state) {\n      if (state.parameterValues)\n        this._setParameterValues(state.parameterValues, false);\n    }\n    _getState() {\n      return { parameterValues: this._getParameterValues(false) };\n    }\n    _getParameterValues(normalized, parameterIds) {\n      const parameterValues = {};\n      if (!parameterIds || !parameterIds.length)\n        parameterIds = Object.keys(this._parameterState);\n      let i = 0;\n      while (i < parameterIds.length) {\n        const id = parameterIds[i];\n        const parameter = this._parameterState[id];\n        parameterValues[id] = {\n          id,\n          value: normalized ? parameter.normalizedValue : parameter.value,\n          normalized\n        };\n        i++;\n      }\n      return parameterValues;\n    }\n    _setParameterValues(parameterUpdates, interpolate) {\n      const parameterIds = Object.keys(parameterUpdates);\n      let i = 0;\n      while (i < parameterIds.length) {\n        this._setParameterValue(parameterUpdates[parameterIds[i]], interpolate);\n        i++;\n      }\n    }\n    _setParameterValue(parameterUpdate, interpolate) {\n      const { id, value, normalized } = parameterUpdate;\n      const parameter = this._parameterState[id];\n      if (!parameter)\n        return;\n      if (!normalized)\n        parameter.value = value;\n      else\n        parameter.normalizedValue = value;\n      const interpolator = this._parameterInterpolators[id];\n      if (interpolate)\n        interpolator.setEndValue(parameter.value);\n      else\n        interpolator.setStartValue(parameter.value);\n    }\n    _interpolateParameterValues(startIndex, endIndex) {\n      const parameterIds = Object.keys(this._parameterInterpolators);\n      let i = 0;\n      while (i < parameterIds.length) {\n        this._parameterInterpolators[parameterIds[i]].process(startIndex, endIndex);\n        i++;\n      }\n    }\n    _connectEvents(wamInstanceId, output) {\n      webAudioModules.connectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    _disconnectEvents(wamInstanceId, output) {\n      if (typeof wamInstanceId === \"undefined\") {\n        webAudioModules.disconnectEvents(this.groupId, this.instanceId);\n        return;\n      }\n      webAudioModules.disconnectEvents(this.groupId, this.instanceId, wamInstanceId, output);\n    }\n    _getProcessingSlices() {\n      const response = \"add/event\";\n      const { currentTime, sampleRate } = audioWorkletGlobalScope;\n      const eventsBySampleIndex = {};\n      let i = 0;\n      while (i < this._eventQueue.length) {\n        const { id, event } = this._eventQueue[i];\n        const offsetSec = event.time - currentTime;\n        const sampleIndex = offsetSec > 0 ? Math.round(offsetSec * sampleRate) : 0;\n        if (sampleIndex < this._samplesPerQuantum) {\n          if (eventsBySampleIndex[sampleIndex])\n            eventsBySampleIndex[sampleIndex].push(event);\n          else\n            eventsBySampleIndex[sampleIndex] = [event];\n          if (id)\n            this.port.postMessage({ id, response });\n          else if (this._eventSabReady)\n            this._eventWriter.write(event);\n          else\n            this.port.postMessage({ event });\n          this._eventQueue.shift();\n          i = -1;\n        } else\n          break;\n        i++;\n      }\n      const processingSlices = [];\n      const keys = Object.keys(eventsBySampleIndex);\n      if (keys[0] !== \"0\") {\n        keys.unshift(\"0\");\n        eventsBySampleIndex[\"0\"] = [];\n      }\n      const lastIndex = keys.length - 1;\n      i = 0;\n      while (i < keys.length) {\n        const key = keys[i];\n        const startSample = parseInt(key);\n        const endSample = i < lastIndex ? parseInt(keys[i + 1]) : this._samplesPerQuantum;\n        processingSlices.push({ range: [startSample, endSample], events: eventsBySampleIndex[key] });\n        i++;\n      }\n      return processingSlices;\n    }\n    _processEvent(event) {\n      switch (event.type) {\n        case \"wam-automation\":\n          this._setParameterValue(event.data, true);\n          break;\n        case \"wam-transport\":\n          this._onTransport(event.data);\n          break;\n        case \"wam-midi\":\n          this._onMidi(event.data);\n          break;\n        case \"wam-sysex\":\n          this._onSysex(event.data);\n          break;\n        case \"wam-mpe\":\n          this._onMpe(event.data);\n          break;\n        case \"wam-osc\":\n          this._onOsc(event.data);\n          break;\n        default:\n          break;\n      }\n    }\n    _process(startSample, endSample, inputs, outputs, parameters) {\n      console.error(\"_process not implemented!\");\n    }\n  }\n  if (audioWorkletGlobalScope.AudioWorkletProcessor) {\n    if (!ModuleScope.WamProcessor)\n      ModuleScope.WamProcessor = WamProcessor;\n  }\n  return WamProcessor;\n};\nvar WamProcessor_default = getWamProcessor;\n\n// src/WamNode.js\nvar RingBuffer = RingBuffer_default();\nvar WamEventRingBuffer = WamEventRingBuffer_default();\nvar WamNode = class extends AudioWorkletNode {\n  static async addModules(audioContext, moduleId) {\n    const { audioWorklet } = audioContext;\n    await addFunctionModule_default(audioWorklet, RingBuffer_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamEventRingBuffer_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamArrayRingBuffer_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamParameter_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamParameterInfo_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamParameterInterpolator_default, moduleId);\n    await addFunctionModule_default(audioWorklet, WamProcessor_default, moduleId);\n  }\n  constructor(module, options) {\n    const { audioContext, groupId, moduleId, instanceId } = module;\n    options.processorOptions = {\n      groupId,\n      moduleId,\n      instanceId,\n      ...options.processorOptions\n    };\n    super(audioContext, moduleId, options);\n    this.module = module;\n    this._supportedEventTypes = /* @__PURE__ */ new Set([\"wam-automation\", \"wam-transport\", \"wam-midi\", \"wam-sysex\", \"wam-mpe\", \"wam-osc\"]);\n    this._messageId = 1;\n    this._pendingResponses = {};\n    this._pendingEvents = {};\n    this._useSab = false;\n    this._eventSabReady = false;\n    this._destroyed = false;\n    this.port.onmessage = this._onMessage.bind(this);\n  }\n  get groupId() {\n    return this.module.groupId;\n  }\n  get moduleId() {\n    return this.module.moduleId;\n  }\n  get instanceId() {\n    return this.module.instanceId;\n  }\n  async getParameterInfo(...parameterIds) {\n    const request = \"get/parameterInfo\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { parameterIds }\n      });\n    });\n  }\n  async getParameterValues(normalized, ...parameterIds) {\n    const request = \"get/parameterValues\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { normalized, parameterIds }\n      });\n    });\n  }\n  async setParameterValues(parameterValues) {\n    const request = \"set/parameterValues\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { parameterValues }\n      });\n    });\n  }\n  async getState() {\n    const request = \"get/state\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({ id, request });\n    });\n  }\n  async setState(state) {\n    const request = \"set/state\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { state }\n      });\n    });\n  }\n  async getCompensationDelay() {\n    const request = \"get/compensationDelay\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({ id, request });\n    });\n  }\n  addEventListener(type, callback, options) {\n    if (this._supportedEventTypes.has(type))\n      super.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    if (this._supportedEventTypes.has(type))\n      super.removeEventListener(type, callback, options);\n  }\n  scheduleEvents(...events) {\n    let i = 0;\n    const numEvents = events.length;\n    if (this._eventSabReady) {\n      i = this._eventWriter.write(...events);\n    }\n    while (i < numEvents) {\n      const event = events[i];\n      const request = \"add/event\";\n      const id = this._generateMessageId();\n      let processed = false;\n      new Promise((resolve, reject) => {\n        this._pendingResponses[id] = resolve;\n        this._pendingEvents[id] = () => {\n          if (!processed)\n            reject();\n        };\n        this.port.postMessage({\n          id,\n          request,\n          content: { event }\n        });\n      }).then((resolved) => {\n        processed = true;\n        delete this._pendingEvents[id];\n        this._onEvent(event);\n      }).catch((rejected) => {\n        delete this._pendingResponses[id];\n      });\n      i++;\n    }\n  }\n  async clearEvents() {\n    const request = \"remove/events\";\n    const id = this._generateMessageId();\n    const ids = Object.keys(this._pendingEvents);\n    if (ids.length) {\n      return new Promise((resolve) => {\n        this._pendingResponses[id] = resolve;\n        this.port.postMessage({ id, request });\n      }).then((clearedIds) => {\n        clearedIds.forEach((clearedId) => {\n          this._pendingEvents[clearedId]();\n          delete this._pendingEvents[clearedId];\n        });\n      });\n    }\n  }\n  connectEvents(toId, output) {\n    const request = \"connect/events\";\n    const id = this._generateMessageId();\n    new Promise((resolve, reject) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { wamInstanceId: toId, output }\n      });\n    });\n  }\n  disconnectEvents(toId, output) {\n    const request = \"disconnect/events\";\n    const id = this._generateMessageId();\n    new Promise((resolve, reject) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({\n        id,\n        request,\n        content: { wamInstanceId: toId, output }\n      });\n    });\n  }\n  destroy() {\n    if (this._audioToMainInterval)\n      clearInterval(this._audioToMainInterval);\n    this.port.postMessage({ destroy: true });\n    this.port.close();\n    this.disconnect();\n    this._destroyed = true;\n  }\n  _generateMessageId() {\n    return this._messageId++;\n  }\n  async _initialize() {\n    const request = \"initialize/processor\";\n    const id = this._generateMessageId();\n    return new Promise((resolve) => {\n      this._pendingResponses[id] = resolve;\n      this.port.postMessage({ id, request });\n    });\n  }\n  _onMessage(message) {\n    const { data } = message;\n    const { response, event, eventSab } = data;\n    if (response) {\n      const { id, content } = data;\n      const resolvePendingResponse = this._pendingResponses[id];\n      if (resolvePendingResponse) {\n        delete this._pendingResponses[id];\n        resolvePendingResponse(content);\n      }\n    } else if (eventSab) {\n      this._useSab = true;\n      const { eventCapacity, parameterIds } = eventSab;\n      if (this._eventSabReady) {\n        this._eventWriter.setParameterIds(parameterIds);\n        this._eventReader.setParameterIds(parameterIds);\n        return;\n      }\n      this._mainToAudioEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n      this._audioToMainEventSab = WamEventRingBuffer.getStorageForEventCapacity(RingBuffer, eventCapacity);\n      this._eventWriter = new WamEventRingBuffer(RingBuffer, this._mainToAudioEventSab, parameterIds);\n      this._eventReader = new WamEventRingBuffer(RingBuffer, this._audioToMainEventSab, parameterIds);\n      const request = \"initialize/eventSab\";\n      const id = this._generateMessageId();\n      new Promise((resolve, reject) => {\n        this._pendingResponses[id] = resolve;\n        this.port.postMessage({\n          id,\n          request,\n          content: {\n            mainToAudioEventSab: this._mainToAudioEventSab,\n            audioToMainEventSab: this._audioToMainEventSab\n          }\n        });\n      }).then((resolved) => {\n        this._eventSabReady = true;\n        this._audioToMainInterval = setInterval(() => {\n          const events = this._eventReader.read();\n          events.forEach((e) => {\n            this._onEvent(e);\n          });\n        }, 100);\n      });\n    } else if (event)\n      this._onEvent(event);\n  }\n  _onEvent(event) {\n    const { type } = event;\n    this.dispatchEvent(new CustomEvent(type, {\n      bubbles: true,\n      detail: event\n    }));\n  }\n};\n\n// src/apiVersion.js\nvar apiVersion_default = \"2.0.0-alpha.4\";\n\n// src/initializeWamHost.js\nvar initializeWamHost = async (audioContext, hostGroupId = `wam-host-${performance.now().toString()}`, hostGroupKey = performance.now().toString()) => {\n  await addFunctionModule_default(audioContext.audioWorklet, WamEnv_default, apiVersion_default);\n  await addFunctionModule_default(audioContext.audioWorklet, WamGroup_default, hostGroupId, hostGroupKey);\n  return [hostGroupId, hostGroupKey];\n};\nvar initializeWamHost_default = initializeWamHost;\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://synth101-wam/../../../node_modules/@webaudiomodules/sdk/dist/index.js?");

/***/ }),

/***/ "../../../node_modules/preact/dist/preact.module.js":
/*!**********************************************************!*\
  !*** ../../../node_modules/preact/dist/preact.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ S),\n/* harmony export */   \"hydrate\": () => (/* binding */ q),\n/* harmony export */   \"createElement\": () => (/* binding */ v),\n/* harmony export */   \"h\": () => (/* binding */ v),\n/* harmony export */   \"Fragment\": () => (/* binding */ d),\n/* harmony export */   \"createRef\": () => (/* binding */ p),\n/* harmony export */   \"isValidElement\": () => (/* binding */ i),\n/* harmony export */   \"Component\": () => (/* binding */ _),\n/* harmony export */   \"cloneElement\": () => (/* binding */ B),\n/* harmony export */   \"createContext\": () => (/* binding */ D),\n/* harmony export */   \"toChildArray\": () => (/* binding */ A),\n/* harmony export */   \"options\": () => (/* binding */ l)\n/* harmony export */ });\nvar n,l,u,i,t,o,r,f,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n)}function v(l,u,i){var t,o,r,f={};for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),\"function\"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return y(l,f,t,o,null)}function y(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u:r};return null!=l.vnode&&l.vnode(f),f}function p(){return{current:null}}function d(n){return n.children}function _(n,l){this.props=n,this.context=l}function k(n,l){if(null==l)return n.__?k(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?k(n):null}function b(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return b(n)}}function m(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!g.__r++||r!==l.debounceRendering)&&((r=l.debounceRendering)||o)(g)}function g(){for(var n;g.__r=t.length;)n=t.sort(function(n,l){return n.__v.__b-l.__v.__b}),t=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=a({},t)).__v=t.__v+1,j(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?k(t):o,t.__h),z(u,t),t.__e!=o&&b(t)))})}function w(n,l,u,i,t,o,r,f,s,a){var h,v,p,_,b,m,g,w=i&&i.__k||c,A=w.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(_=u.__k[h]=null==(_=l[h])||\"boolean\"==typeof _?null:\"string\"==typeof _||\"number\"==typeof _||\"bigint\"==typeof _?y(null,_,null,null,_):Array.isArray(_)?y(d,{children:_},null,null,null):_.__b>0?y(_.type,_.props,_.key,null,_.__v):_)){if(_.__=u,_.__b=u.__b+1,null===(p=w[h])||p&&_.key==p.key&&_.type===p.type)w[h]=void 0;else for(v=0;v<A;v++){if((p=w[v])&&_.key==p.key&&_.type===p.type){w[v]=void 0;break}p=null}j(n,_,p=p||e,t,o,r,f,s,a),b=_.__e,(v=_.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,_),g.push(v,_.__c||b,_)),null!=b?(null==m&&(m=b),\"function\"==typeof _.type&&null!=_.__k&&_.__k===p.__k?_.__d=s=x(_,s,n):s=P(n,_,p,w,b,s),a||\"option\"!==u.type?\"function\"==typeof u.type&&(u.__d=s):n.value=\"\"):s&&p.__e==s&&s.parentNode!=n&&(s=k(p))}for(u.__e=m,h=A;h--;)null!=w[h]&&(\"function\"==typeof u.type&&null!=w[h].__e&&w[h].__e==u.__d&&(u.__d=k(i,h+1)),N(w[h],w[h]));if(g)for(h=0;h<g.length;h++)M(g[h],g[++h],g[++h])}function x(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,l=\"function\"==typeof t.type?x(t,l,u):P(u,t,t,n.__k,t.__e,l));return l}function A(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(Array.isArray(n)?n.some(function(n){A(n,l)}):l.push(n)),l}function P(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else{for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o}return void 0!==r?r:t.nextSibling}function C(n,l,u,i,t){var o;for(o in u)\"children\"===o||\"key\"===o||o in l||H(n,o,null,u[o],i);for(o in l)t&&\"function\"!=typeof l[o]||\"children\"===o||\"key\"===o||\"value\"===o||\"checked\"===o||u[o]===l[o]||H(n,o,l[o],u[o],i)}function $(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=null==u?\"\":\"number\"!=typeof u||s.test(l)?u:u+\"px\"}function H(n,l,u,i,t){var o;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof i&&(n.style.cssText=i=\"\"),i)for(l in i)u&&l in u||$(n.style,l,\"\");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])o=l!==(l=l.replace(/Capture$/,\"\")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T:I,o):n.removeEventListener(l,o?T:I,o);else if(\"dangerouslySetInnerHTML\"!==l){if(t)l=l.replace(/xlink[H:h]/,\"h\").replace(/sName$/,\"s\");else if(\"href\"!==l&&\"list\"!==l&&\"form\"!==l&&\"tabIndex\"!==l&&\"download\"!==l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null!=u&&(!1!==u||\"a\"===l[0]&&\"r\"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function I(n){this.l[n.type+!1](l.event?l.event(n):n)}function T(n){this.l[n.type+!0](l.event?l.event(n):n)}function j(n,u,i,t,o,r,f,e,c){var s,h,v,y,p,k,b,m,g,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(s=l.__b)&&s(u);try{n:if(\"function\"==typeof P){if(m=u.props,g=(s=P.contextType)&&t[s.__c],x=s?g?g.props.value:s.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:(\"prototype\"in P&&P.prototype.render?u.__c=h=new P(m,x):(u.__c=h=new _(m,x),h.constructor=P,h.render=O),g&&g.sub(h),h.props=m,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=a({},h.__s)),a(h.__s,P.getDerivedStateFromProps(m,h.__s))),y=h.props,p=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,x)||u.__v===i.__v){h.props=m,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u)}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,p,k)})}h.context=x,h.props=m,h.state=h.__s,(s=l.__r)&&s(u),h.__d=!1,h.__v=u,h.__P=n,s=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(t=a(a({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,p)),A=null!=s&&s.type===d&&null==s.key?s.props.children:s,w(n,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L(i.__e,u,i,t,o,r,f,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l.__e(n,u,i)}}function z(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function L(l,u,i,t,o,r,f,c){var s,a,v,y=i.props,p=u.props,d=u.type,_=0;if(\"svg\"===d&&(o=!0),null!=r)for(;_<r.length;_++)if((s=r[_])&&(s===l||(d?s.localName==d:3==s.nodeType))){l=s,r[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS(\"http://www.w3.org/2000/svg\",d):document.createElement(d,p.is&&p),r=null,c=!1}if(null===d)y===p||c&&l.data===p||(l.data=p);else{if(r=r&&n.call(l.childNodes),a=(y=i.props||e).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(v||a)&&(v&&(a&&v.__html==a.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||\"\"))}if(C(l,p,y,o,c),v)u.__k=[];else if(_=u.props.children,w(l,Array.isArray(_)?_:[_],u,i,t,o&&\"foreignObject\"!==d,r,f,r?r[0]:i.__k&&k(i,0),c),null!=r)for(_=r.length;_--;)null!=r[_]&&h(r[_]);c||(\"value\"in p&&void 0!==(_=p.value)&&(_!==l.value||\"progress\"===d&&!_)&&H(l,\"value\",_,y.value,!1),\"checked\"in p&&void 0!==(_=p.checked)&&_!==l.checked&&H(l,\"checked\",_,y.checked,!1))}return l}function M(n,u,i){try{\"function\"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function N(n,u,i){var t,o;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,\"function\"!=typeof n.type);i||null==n.__e||h(n.__e),n.__e=n.__d=void 0}function O(n,l,u){return this.constructor(n,u)}function S(u,i,t){var o,r,f;l.__&&l.__(u,i),r=(o=\"function\"==typeof t)?null:t&&t.__k||i.__k,f=[],j(i,u=(!o&&t||i).__k=v(d,null,[u]),r||e,e,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,f,!o&&t?t:r?r.__e:i.firstChild,o),z(f,u)}function q(n,l){S(n,l,q)}function B(l,u,i){var t,o,r,f=a({},l.props);for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),y(l.type,f,t||l.key,o||l.ref,null)}function D(n,l){var u={__c:l=\"__cC\"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(m)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=c.slice,l={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l}throw n}},u=0,i=function(n){return null!=n&&void 0===n.constructor},_.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),\"function\"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),m(this))},_.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),m(this))},_.prototype.render=d,t=[],o=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,g.__r=0,f=0;\n//# sourceMappingURL=preact.module.js.map\n\n\n//# sourceURL=webpack://synth101-wam/../../../node_modules/preact/dist/preact.module.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n\n      content += cssWithMappingToString(item);\n\n      if (needLayer) {\n        content += \"}\";\n      }\n\n      if (item[2]) {\n        content += \"}\";\n      }\n\n      if (item[4]) {\n        content += \"}\";\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n\n\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://synth101-wam/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://synth101-wam/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./src/Synth101.scss":
/*!***************************!*\
  !*** ./src/Synth101.scss ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".ComponentWrapper {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  text-align: center;\\n  flex: 1;\\n  padding: 4px;\\n}\\n\\n.Fader {\\n  margin-top: auto;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.Knob {\\n  margin-top: auto;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.ComponentSelect {\\n  margin-bottom: auto;\\n  margin-top: auto;\\n  margin-bottom: auto;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.GlowModalBackdrop {\\n  position: fixed;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n  background-color: rgba(0, 0, 0, 0.3);\\n  padding: 50px;\\n  z-index: 99999998;\\n}\\n\\n.GlowModalContainer {\\n  position: fixed;\\n  top: 50%;\\n  left: 50%;\\n  transform: translate(-50%, -50%);\\n  margin: 0 auto;\\n  z-index: 99999998;\\n}\\n\\n.yLtUbqISb2SBopn1M7Ur {\\n  background-color: #4773cc;\\n  display: flex;\\n  flex: 1;\\n  height: 100%;\\n  width: 100%;\\n}\\n\\n.xyQMfyMuz95OiV0M8XzB {\\n  color: white;\\n  display: flex;\\n  justify-content: center;\\n  margin: auto;\\n}\\n\\n.oGKVJIwRJSnXrc7bKrEA {\\n  /* border: 1px solid white; */\\n  border: 1px solid rgba(0, 0, 0, 0.3);\\n  border-radius: 2px;\\n  margin: 5px;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.tuu5GfMXj9lz5tFv_kj9 {\\n  background-color: rgba(0, 0, 0, 0.2);\\n  padding: 2px;\\n}\\n\\n.sqA2X0eOCl8kpcOP7cWa {\\n  display: flex;\\n  justify-content: stretch;\\n  flex: 1;\\n  padding: 10px;\\n}\", \"\"]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"root\": \"yLtUbqISb2SBopn1M7Ur\",\n\t\"synth101\": \"xyQMfyMuz95OiV0M8XzB\",\n\t\"section\": \"oGKVJIwRJSnXrc7bKrEA\",\n\t\"header\": \"tuu5GfMXj9lz5tFv_kj9\",\n\t\"content\": \"sqA2X0eOCl8kpcOP7cWa\"\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://synth101-wam/./src/Synth101.scss?");

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ S),\n/* harmony export */   \"hydrate\": () => (/* binding */ q),\n/* harmony export */   \"createElement\": () => (/* binding */ v),\n/* harmony export */   \"h\": () => (/* binding */ v),\n/* harmony export */   \"Fragment\": () => (/* binding */ d),\n/* harmony export */   \"createRef\": () => (/* binding */ p),\n/* harmony export */   \"isValidElement\": () => (/* binding */ i),\n/* harmony export */   \"Component\": () => (/* binding */ _),\n/* harmony export */   \"cloneElement\": () => (/* binding */ B),\n/* harmony export */   \"createContext\": () => (/* binding */ D),\n/* harmony export */   \"toChildArray\": () => (/* binding */ A),\n/* harmony export */   \"options\": () => (/* binding */ l)\n/* harmony export */ });\nvar n,l,u,i,t,o,r,f,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n)}function v(l,u,i){var t,o,r,f={};for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),\"function\"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return y(l,f,t,o,null)}function y(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u:r};return null!=l.vnode&&l.vnode(f),f}function p(){return{current:null}}function d(n){return n.children}function _(n,l){this.props=n,this.context=l}function k(n,l){if(null==l)return n.__?k(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?k(n):null}function b(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return b(n)}}function m(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!g.__r++||r!==l.debounceRendering)&&((r=l.debounceRendering)||o)(g)}function g(){for(var n;g.__r=t.length;)n=t.sort(function(n,l){return n.__v.__b-l.__v.__b}),t=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=a({},t)).__v=t.__v+1,j(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?k(t):o,t.__h),z(u,t),t.__e!=o&&b(t)))})}function w(n,l,u,i,t,o,r,f,s,a){var h,v,p,_,b,m,g,w=i&&i.__k||c,A=w.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(_=u.__k[h]=null==(_=l[h])||\"boolean\"==typeof _?null:\"string\"==typeof _||\"number\"==typeof _||\"bigint\"==typeof _?y(null,_,null,null,_):Array.isArray(_)?y(d,{children:_},null,null,null):_.__b>0?y(_.type,_.props,_.key,null,_.__v):_)){if(_.__=u,_.__b=u.__b+1,null===(p=w[h])||p&&_.key==p.key&&_.type===p.type)w[h]=void 0;else for(v=0;v<A;v++){if((p=w[v])&&_.key==p.key&&_.type===p.type){w[v]=void 0;break}p=null}j(n,_,p=p||e,t,o,r,f,s,a),b=_.__e,(v=_.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,_),g.push(v,_.__c||b,_)),null!=b?(null==m&&(m=b),\"function\"==typeof _.type&&null!=_.__k&&_.__k===p.__k?_.__d=s=x(_,s,n):s=P(n,_,p,w,b,s),a||\"option\"!==u.type?\"function\"==typeof u.type&&(u.__d=s):n.value=\"\"):s&&p.__e==s&&s.parentNode!=n&&(s=k(p))}for(u.__e=m,h=A;h--;)null!=w[h]&&(\"function\"==typeof u.type&&null!=w[h].__e&&w[h].__e==u.__d&&(u.__d=k(i,h+1)),N(w[h],w[h]));if(g)for(h=0;h<g.length;h++)M(g[h],g[++h],g[++h])}function x(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,l=\"function\"==typeof t.type?x(t,l,u):P(u,t,t,n.__k,t.__e,l));return l}function A(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(Array.isArray(n)?n.some(function(n){A(n,l)}):l.push(n)),l}function P(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else{for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o}return void 0!==r?r:t.nextSibling}function C(n,l,u,i,t){var o;for(o in u)\"children\"===o||\"key\"===o||o in l||H(n,o,null,u[o],i);for(o in l)t&&\"function\"!=typeof l[o]||\"children\"===o||\"key\"===o||\"value\"===o||\"checked\"===o||u[o]===l[o]||H(n,o,l[o],u[o],i)}function $(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=null==u?\"\":\"number\"!=typeof u||s.test(l)?u:u+\"px\"}function H(n,l,u,i,t){var o;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof i&&(n.style.cssText=i=\"\"),i)for(l in i)u&&l in u||$(n.style,l,\"\");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])o=l!==(l=l.replace(/Capture$/,\"\")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T:I,o):n.removeEventListener(l,o?T:I,o);else if(\"dangerouslySetInnerHTML\"!==l){if(t)l=l.replace(/xlink[H:h]/,\"h\").replace(/sName$/,\"s\");else if(\"href\"!==l&&\"list\"!==l&&\"form\"!==l&&\"tabIndex\"!==l&&\"download\"!==l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null!=u&&(!1!==u||\"a\"===l[0]&&\"r\"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function I(n){this.l[n.type+!1](l.event?l.event(n):n)}function T(n){this.l[n.type+!0](l.event?l.event(n):n)}function j(n,u,i,t,o,r,f,e,c){var s,h,v,y,p,k,b,m,g,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(s=l.__b)&&s(u);try{n:if(\"function\"==typeof P){if(m=u.props,g=(s=P.contextType)&&t[s.__c],x=s?g?g.props.value:s.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:(\"prototype\"in P&&P.prototype.render?u.__c=h=new P(m,x):(u.__c=h=new _(m,x),h.constructor=P,h.render=O),g&&g.sub(h),h.props=m,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=a({},h.__s)),a(h.__s,P.getDerivedStateFromProps(m,h.__s))),y=h.props,p=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,x)||u.__v===i.__v){h.props=m,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u)}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,p,k)})}h.context=x,h.props=m,h.state=h.__s,(s=l.__r)&&s(u),h.__d=!1,h.__v=u,h.__P=n,s=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(t=a(a({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,p)),A=null!=s&&s.type===d&&null==s.key?s.props.children:s,w(n,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L(i.__e,u,i,t,o,r,f,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l.__e(n,u,i)}}function z(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function L(l,u,i,t,o,r,f,c){var s,a,v,y=i.props,p=u.props,d=u.type,_=0;if(\"svg\"===d&&(o=!0),null!=r)for(;_<r.length;_++)if((s=r[_])&&(s===l||(d?s.localName==d:3==s.nodeType))){l=s,r[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS(\"http://www.w3.org/2000/svg\",d):document.createElement(d,p.is&&p),r=null,c=!1}if(null===d)y===p||c&&l.data===p||(l.data=p);else{if(r=r&&n.call(l.childNodes),a=(y=i.props||e).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(v||a)&&(v&&(a&&v.__html==a.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||\"\"))}if(C(l,p,y,o,c),v)u.__k=[];else if(_=u.props.children,w(l,Array.isArray(_)?_:[_],u,i,t,o&&\"foreignObject\"!==d,r,f,r?r[0]:i.__k&&k(i,0),c),null!=r)for(_=r.length;_--;)null!=r[_]&&h(r[_]);c||(\"value\"in p&&void 0!==(_=p.value)&&(_!==l.value||\"progress\"===d&&!_)&&H(l,\"value\",_,y.value,!1),\"checked\"in p&&void 0!==(_=p.checked)&&_!==l.checked&&H(l,\"checked\",_,y.checked,!1))}return l}function M(n,u,i){try{\"function\"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function N(n,u,i){var t,o;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,\"function\"!=typeof n.type);i||null==n.__e||h(n.__e),n.__e=n.__d=void 0}function O(n,l,u){return this.constructor(n,u)}function S(u,i,t){var o,r,f;l.__&&l.__(u,i),r=(o=\"function\"==typeof t)?null:t&&t.__k||i.__k,f=[],j(i,u=(!o&&t||i).__k=v(d,null,[u]),r||e,e,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,f,!o&&t?t:r?r.__e:i.firstChild,o),z(f,u)}function q(n,l){S(n,l,q)}function B(l,u,i){var t,o,r,f=a({},l.props);for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),y(l.type,f,t||l.key,o||l.ref,null)}function D(n,l){var u={__c:l=\"__cC\"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(m)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=c.slice,l={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l}throw n}},u=0,i=function(n){return null!=n&&void 0===n.constructor},_.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),\"function\"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),m(this))},_.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),m(this))},_.prototype.render=d,t=[],o=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,g.__r=0,f=0;\n//# sourceMappingURL=preact.module.js.map\n\n\n//# sourceURL=webpack://synth101-wam/./node_modules/preact/dist/preact.module.js?");

/***/ }),

/***/ "../shared/getBaseUrl.tsx":
/*!********************************!*\
  !*** ../shared/getBaseUrl.tsx ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getBaseUrl\": () => (/* binding */ getBaseUrl)\n/* harmony export */ });\nconst getBaseUrl = (relativeURL) => {\n    const baseURL = relativeURL.href.substring(0, relativeURL.href.lastIndexOf('/'));\n    return baseURL;\n};\n\n\n//# sourceURL=webpack://synth101-wam/../shared/getBaseUrl.tsx?");

/***/ }),

/***/ "../shared/insertStyle.ts":
/*!********************************!*\
  !*** ../shared/insertStyle.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"insertStyle\": () => (/* binding */ insertStyle)\n/* harmony export */ });\nfunction insertStyle(shadow, style) {\n    const el = document.createElement('style');\n    el.textContent = style;\n    shadow.appendChild(el);\n}\n\n\n//# sourceURL=webpack://synth101-wam/../shared/insertStyle.ts?");

/***/ }),

/***/ "../shared/midi.ts":
/*!*************************!*\
  !*** ../shared/midi.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MIDI\": () => (/* binding */ MIDI)\n/* harmony export */ });\nclass MIDI {\n}\nMIDI.NOTE_ON = 0x90;\nMIDI.NOTE_OFF = 0x80;\nMIDI.CC = 0xB0;\n\n\n//# sourceURL=webpack://synth101-wam/../shared/midi.ts?");

/***/ }),

/***/ "../shared/ui/Fader.tsx":
/*!******************************!*\
  !*** ../shared/ui/Fader.tsx ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Fader\": () => (/* binding */ Fader)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"../../../node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./svg */ \"../shared/ui/svg.ts\");\n\n\nclass Fader extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super();\n        this.pressed = false;\n        this.onMousemove = this.onMousemove.bind(this);\n        this.onMouseup = this.onMouseup.bind(this);\n        this.animationFrame = this.animationFrame.bind(this);\n        this.scheduleFrame = this.scheduleFrame.bind(this);\n        this.scheduleAnimation = this.scheduleAnimation.bind(this);\n    }\n    componentWillUnmount() {\n        if (this.pressed) {\n            window.removeEventListener('mousemove', this.onMousemove);\n            window.removeEventListener('mouseup', this.onMouseup);\n        }\n        this.cancelAnimation();\n    }\n    cancelAnimation() {\n        if (this.animationTimeout != undefined) {\n            window.clearTimeout(this.animationTimeout);\n            this.animationTimeout = undefined;\n        }\n        if (this.animationRequest != undefined) {\n            window.cancelAnimationFrame(this.animationRequest);\n            this.animationRequest = undefined;\n        }\n    }\n    scheduleAnimation() {\n        this.animationTimeout = window.setTimeout(this.scheduleFrame, this.pressed ? 10 : 100);\n    }\n    scheduleFrame() {\n        this.animationRequest = window.requestAnimationFrame(this.animationFrame);\n    }\n    animationFrame() {\n        let newValue = this.props.value();\n        let newAutomationValue = this.props.automationValue ? this.props.automationValue() : undefined;\n        if (newValue == this.lastValue && newAutomationValue == this.lastAutomationValue) {\n            this.scheduleAnimation();\n            return;\n        }\n        if (this.valueLabel) {\n            if (this.props.valueString) {\n                this.valueLabel.innerText = this.props.valueString(newValue);\n            }\n            else {\n                this.valueLabel.innerText = `${newValue.toFixed(this.props.decimals)}${this.props.units}`;\n            }\n        }\n        var percent = (newValue - this.props.minimumValue) / (this.props.maximumValue - this.props.minimumValue);\n        var position = (this.props.height - this.props.capHeight) - ((this.props.height - this.props.capHeight) * percent);\n        if (this.lastValue != newValue) {\n            (0,_svg__WEBPACK_IMPORTED_MODULE_1__.svg_update_rectangle)(this.fader, this.center - (this.props.capWidth / 2), position, this.props.capWidth, this.props.capHeight, this.props.color);\n        }\n        if (newAutomationValue || newAutomationValue === 0) {\n            percent = (newAutomationValue - this.props.minimumValue) / (this.props.maximumValue - this.props.minimumValue);\n            let automatedPosition = (this.props.height) - ((this.props.height) * percent);\n            let x = this.center;\n            (0,_svg__WEBPACK_IMPORTED_MODULE_1__.svg_update_line)(this.automatedValueTrack, x, automatedPosition, x, position, \"white\");\n        }\n        this.lastAutomationValue = newAutomationValue;\n        this.lastValue = newValue;\n        this.scheduleAnimation();\n    }\n    setup(ref) {\n        if (ref == null) {\n            return;\n        }\n        if (this.ref == ref) {\n            return;\n        }\n        this.ref = ref;\n        ref.innerHTML = \"\";\n        this.svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        this.svg.setAttribute('style', \"stroke:black; fill:none; stroke-width:2\");\n        this.svg.setAttribute('width', `${this.props.width}px`);\n        this.svg.setAttribute('height', `${this.props.height}`);\n        this.center = this.props.width / 2;\n        let track = (0,_svg__WEBPACK_IMPORTED_MODULE_1__.svg_line)(this.center, 0, this.center, this.props.height, \"black\");\n        this.automatedValueTrack = (0,_svg__WEBPACK_IMPORTED_MODULE_1__.svg_line)(this.center, 0, this.center, this.props.height, \"white\");\n        this.fader = (0,_svg__WEBPACK_IMPORTED_MODULE_1__.svg_create)(\"rect\");\n        this.svg.appendChild(track);\n        if (this.props.automationValue) {\n            this.svg.appendChild(this.automatedValueTrack);\n        }\n        this.svg.appendChild(this.fader);\n        ref.appendChild(this.svg);\n        this.cancelAnimation();\n        this.animationFrame();\n    }\n    onMousedown(e) {\n        this.pressed = true;\n        this.position = { x: e.screenX, y: e.screenY };\n        window.addEventListener('mousemove', this.onMousemove);\n        window.addEventListener('mouseup', this.onMouseup);\n    }\n    onMouseup(e) {\n        this.pressed = false;\n        window.removeEventListener('mousemove', this.onMousemove);\n        window.removeEventListener('mouseup', this.onMouseup);\n    }\n    onMousemove(e) {\n        if (this.pressed) {\n            let distance = (e.screenY - this.position.y);\n            this.position = { x: e.screenX, y: e.screenY };\n            this.setValue(this.props.value() - (distance * 0.01 * (this.props.maximumValue - this.props.minimumValue)));\n        }\n    }\n    setValue(v) {\n        if (v > this.props.maximumValue) {\n            v = this.props.maximumValue;\n        }\n        if (v < this.props.minimumValue) {\n            v = this.props.minimumValue;\n        }\n        if (this.props.onChange) {\n            this.props.onChange(v);\n        }\n    }\n    render() {\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {});\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: \"ComponentWrapper\" },\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"label\", null, this.props.label ? this.props.label : \"\"),\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { ref: (ref) => this.setup(ref), class: \"Fader\", onMouseDown: (e) => this.onMousedown(e) }),\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"small\", null,\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"label\", { ref: ref => { this.valueLabel = ref; this.lastValue = undefined; } })));\n    }\n}\nFader.defaultProps = {\n    minimumValue: 0.0,\n    maximumValue: 1.0,\n    width: 30,\n    height: 120,\n    capWidth: 20,\n    capHeight: 8,\n    color: 'yellow',\n    units: \"\",\n    decimals: 2,\n    showValue: true\n};\n\n\n//# sourceURL=webpack://synth101-wam/../shared/ui/Fader.tsx?");

/***/ }),

/***/ "../shared/ui/Knob.tsx":
/*!*****************************!*\
  !*** ../shared/ui/Knob.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Knob\": () => (/* binding */ Knob)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"../../../node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./svg */ \"../shared/ui/svg.ts\");\n\n\nclass Knob extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super();\n        this.pressed = false;\n        this.onMousemove = this.onMousemove.bind(this);\n        this.onMouseup = this.onMouseup.bind(this);\n        this.animationFrame = this.animationFrame.bind(this);\n        this.scheduleFrame = this.scheduleFrame.bind(this);\n        this.scheduleAnimation = this.scheduleAnimation.bind(this);\n    }\n    componentDidMount() {\n    }\n    componentWillUnmount() {\n        if (this.pressed) {\n            window.removeEventListener('mousemove', this.onMousemove);\n            window.removeEventListener('mouseup', this.onMouseup);\n        }\n        this.cancelAnimation();\n    }\n    cancelAnimation() {\n        if (this.animationTimeout != undefined) {\n            window.clearTimeout(this.animationTimeout);\n            this.animationTimeout = undefined;\n        }\n        if (this.animationRequest != undefined) {\n            window.cancelAnimationFrame(this.animationRequest);\n            this.animationRequest = undefined;\n        }\n    }\n    scheduleAnimation() {\n        this.animationTimeout = window.setTimeout(this.scheduleFrame, this.pressed ? 10 : 100);\n    }\n    scheduleFrame() {\n        this.animationRequest = window.requestAnimationFrame(this.animationFrame);\n    }\n    animationFrame() {\n        let newValue = this.props.value();\n        if (newValue == this.lastValue) {\n            this.scheduleAnimation();\n            return;\n        }\n        this.lastValue = newValue;\n        if (this.valueLabel) {\n            if (this.props.valueString) {\n                this.valueLabel.innerText = this.props.valueString(newValue);\n            }\n            else if (this.props.integer) {\n                this.valueLabel.innerText = `${newValue.toFixed(0)}${this.props.units}`;\n            }\n            else {\n                this.valueLabel.innerText = `${newValue.toFixed(this.props.decimals)}${this.props.units}`;\n            }\n        }\n        if (this.props.bipolar) {\n            let midValue = (this.props.maximumValue + this.props.minimumValue) / 2;\n            let percent = (newValue - midValue) / (midValue - this.props.minimumValue);\n            (0,_svg__WEBPACK_IMPORTED_MODULE_1__.svg_update_arc)(this.arc, this.center, this.radii, [270, 135 * percent], 0);\n        }\n        else {\n            let percent = (newValue - this.props.minimumValue) / (this.props.maximumValue - this.props.minimumValue);\n            (0,_svg__WEBPACK_IMPORTED_MODULE_1__.svg_update_arc)(this.arc, this.center, this.radii, [135, 270 * percent], 0);\n        }\n        this.scheduleAnimation();\n    }\n    setup(ref) {\n        if (ref == null) {\n            return;\n        }\n        if (this.ref == ref) {\n            return;\n        }\n        this.ref = ref;\n        ref.innerHTML = \"\";\n        this.svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        this.svg.setAttribute('style', \"stroke:var(--var-ControlBackground); fill:none; stroke-width:2\");\n        this.svg.setAttribute('width', `${this.props.size}`);\n        this.svg.setAttribute('height', `${this.props.size * 4 / 5}`);\n        this.center = [this.props.size / 2, this.props.size / 2];\n        this.radii = [this.center[0] - this.props.padding, this.center[1] - this.props.padding];\n        this.range = (0,_svg__WEBPACK_IMPORTED_MODULE_1__.svg_arc)(this.center, this.radii, [136, 270], 0);\n        this.range.setAttribute('style', 'stroke:var(--var-ControlBackground);');\n        this.svg.appendChild(this.range);\n        ref.appendChild(this.svg);\n        this.arc = (0,_svg__WEBPACK_IMPORTED_MODULE_1__.svg_create)(\"path\");\n        this.arc.setAttribute('style', `stroke:${this.props.color};`);\n        this.svg.appendChild(this.arc);\n        this.cancelAnimation();\n        this.animationFrame();\n    }\n    onDoubleClick(e) {\n        if (this.props.defaultValue !== undefined) {\n            this.setValue(this.props.defaultValue);\n        }\n    }\n    onMousedown(e) {\n        this.pressed = true;\n        this.position = { x: e.screenX, y: e.screenY };\n        this.dragStartValue = this.props.value();\n        window.addEventListener('mousemove', this.onMousemove);\n        window.addEventListener('mouseup', this.onMouseup);\n    }\n    onMouseup(e) {\n        this.pressed = false;\n        this.dragStartValue = undefined;\n        window.removeEventListener('mousemove', this.onMousemove);\n        window.removeEventListener('mouseup', this.onMouseup);\n    }\n    onMousemove(e) {\n        if (this.pressed) {\n            let distance = (e.screenX - this.position.x) - (e.screenY - this.position.y);\n            if (!this.props.integer || Math.abs(distance) > 0.5) {\n                this.setValue(this.dragStartValue + (distance * 0.005 * (this.props.maximumValue - this.props.minimumValue)));\n            }\n        }\n    }\n    setValue(v) {\n        if (v > this.props.maximumValue) {\n            v = this.props.maximumValue;\n        }\n        if (v < this.props.minimumValue) {\n            v = this.props.minimumValue;\n        }\n        if (this.props.onChange) {\n            this.props.onChange(v);\n        }\n    }\n    render() {\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {});\n        let value;\n        if (this.props.showValue) {\n            value = (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"small\", null,\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"label\", { ref: ref => { this.valueLabel = ref; this.lastValue = undefined; } }));\n        }\n        return ((0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: \"ComponentWrapper\" },\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"label\", null, this.props.label),\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { ref: (ref) => this.setup(ref), class: \"Knob\", style: `height: ${this.props.size}px; width: ${this.props.size}px;`, onMouseDown: (e) => this.onMousedown(e), onDblClick: (e) => this.onDoubleClick(e) }),\n            value));\n    }\n}\nKnob.defaultProps = {\n    minimumValue: 0.0,\n    maximumValue: 1.0,\n    size: 50,\n    value: 0.5,\n    padding: 3,\n    integer: false,\n    color: 'yellow',\n    label: \"\",\n    bipolar: false,\n    units: \"\",\n    decimals: 2,\n    showValue: true,\n};\n\n\n//# sourceURL=webpack://synth101-wam/../shared/ui/Knob.tsx?");

/***/ }),

/***/ "../shared/ui/Select.tsx":
/*!*******************************!*\
  !*** ../shared/ui/Select.tsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Select\": () => (/* binding */ Select)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"../../../node_modules/preact/dist/preact.module.js\");\n\nclass Select extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super();\n        this.lastRenderedValue = \"-1\";\n        this.animationFrame = this.animationFrame.bind(this);\n        this.scheduleFrame = this.scheduleFrame.bind(this);\n        this.scheduleAnimation = this.scheduleAnimation.bind(this);\n    }\n    onChange(e) {\n        if (this.props.onChange) {\n            this.props.onChange(e.target.value);\n        }\n    }\n    cancelAnimation() {\n        if (this.animationTimeout != undefined) {\n            window.clearTimeout(this.animationTimeout);\n            this.animationTimeout = undefined;\n        }\n        if (this.animationRequest != undefined) {\n            window.cancelAnimationFrame(this.animationRequest);\n            this.animationRequest = undefined;\n        }\n    }\n    scheduleAnimation() {\n        this.animationTimeout = window.setTimeout(this.scheduleFrame, 100);\n    }\n    scheduleFrame() {\n        this.animationRequest = window.requestAnimationFrame(this.animationFrame);\n    }\n    componentWillUnmount() {\n        this.cancelAnimation();\n    }\n    animationFrame() {\n        let newValue = this.props.value();\n        if (this.lastRenderedValue == newValue) {\n            this.scheduleAnimation();\n            return;\n        }\n        this.lastRenderedValue = newValue;\n        for (let option of this.select.options) {\n            option.selected = (option.value == newValue);\n        }\n        this.scheduleAnimation();\n    }\n    setup(ref) {\n        if (ref == null) {\n            return;\n        }\n        if (ref == this.ref && this.sameArray(this.props.options, this.renderedOptions) && this.sameArray(this.props.values, this.renderedValues)) {\n            return;\n        }\n        this.ref = ref;\n        ref.innerHTML = \"\";\n        if (this.props.value === undefined || this.props.value === null) {\n            throw `Select with label ${this.props.label} values ${this.props.values} has null value`;\n        }\n        if (!this.select) {\n            this.select = document.createElement(\"select\");\n            this.select.addEventListener(\"change\", e => this.onChange(e));\n        }\n        else {\n            while (this.select.firstChild) {\n                this.select.removeChild(this.select.firstChild);\n            }\n            try {\n                this.ref.removeChild(this.select);\n            }\n            catch (e) {\n            }\n        }\n        this.ref.appendChild(this.select);\n        this.props.options.forEach((name, index) => {\n            let option = document.createElement(\"option\");\n            option.text = name;\n            option.value = (this.props.values) ? this.props.values[index].toString() : index.toString();\n            this.select.appendChild(option);\n        });\n        this.lastRenderedValue = \"-1\";\n        this.renderedOptions = this.props.options;\n        this.renderedValues = this.props.values;\n        this.cancelAnimation();\n        this.animationFrame();\n    }\n    render() {\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {});\n        let style = this.props.style ? this.props.style : \"\";\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: \"ComponentWrapper\", style: style },\n            this.props.label && (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"label\", null, this.props.label),\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { ref: (e) => this.setup(e), style: \"color: black;\", class: \"ComponentSelect\" }));\n    }\n    sameArray(lhs, rhs) {\n        if (lhs === undefined && rhs === undefined) {\n            return true;\n        }\n        if (lhs === undefined || rhs === undefined) {\n            return false;\n        }\n        return (lhs.length == rhs.length && lhs.every((l, i) => l == rhs[i]));\n    }\n}\n\n\n//# sourceURL=webpack://synth101-wam/../shared/ui/Select.tsx?");

/***/ }),

/***/ "../shared/ui/svg.ts":
/*!***************************!*\
  !*** ../shared/ui/svg.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"svg_create\": () => (/* binding */ svg_create),\n/* harmony export */   \"svg_arc\": () => (/* binding */ svg_arc),\n/* harmony export */   \"svg_update_arc\": () => (/* binding */ svg_update_arc),\n/* harmony export */   \"svg_rectangle\": () => (/* binding */ svg_rectangle),\n/* harmony export */   \"svg_update_rectangle\": () => (/* binding */ svg_update_rectangle),\n/* harmony export */   \"svg_text\": () => (/* binding */ svg_text),\n/* harmony export */   \"svg_line\": () => (/* binding */ svg_line),\n/* harmony export */   \"svg_update_line\": () => (/* binding */ svg_update_line)\n/* harmony export */ });\n\nconst svgns = \"http://www.w3.org/2000/svg\";\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst π = Math.PI;\nconst f_matrix_times = (([[a, b], [c, d]], [x, y]) => [a * x + b * y, c * x + d * y]);\nconst f_rotate_matrix = ((x) => {\n    const cosx = cos(x);\n    const sinx = sin(x);\n    return [[cosx, -sinx], [sinx, cosx]];\n});\nconst f_vec_add = (([a1, a2], [b1, b2]) => [a1 + b1, a2 + b2]);\nfunction svg_create(type) {\n    return document.createElementNS(svgns, type);\n}\nfunction svg_arc([cx, cy], [rx, ry], [t1, Δ], φ) {\n    const path = document.createElementNS(svgns, \"path\");\n    svg_update_arc(path, [cx, cy], [rx, ry], [t1, Δ], φ);\n    return path;\n}\n;\nfunction svg_update_arc(arc, [cx, cy], [rx, ry], [t1, Δ], φ) {\n    Δ = Δ / 180 * π;\n    Δ = Δ % (2 * π);\n    t1 = t1 / 180 * π;\n    const rotMatrix = f_rotate_matrix(φ);\n    const [sX, sY] = (f_vec_add(f_matrix_times(rotMatrix, [rx * cos(t1), ry * sin(t1)]), [cx, cy]));\n    const [eX, eY] = (f_vec_add(f_matrix_times(rotMatrix, [rx * cos(t1 + Δ), ry * sin(t1 + Δ)]), [cx, cy]));\n    const fA = ((Δ > π) ? 1 : 0);\n    const fS = ((Δ > 0) ? 1 : 0);\n    let cmd = [\" M \", sX, \" \", sY, \" A \", rx, ry, φ / π * 180, fA, fS, eX, eY].join(\" \");\n    arc.setAttribute(\"d\", cmd);\n}\nfunction svg_rectangle(x, y, width, height, fill) {\n    var rect = document.createElementNS(svgns, 'rect');\n    svg_update_rectangle(rect, x, y, width, height, fill);\n    return rect;\n}\nfunction svg_update_rectangle(rect, x, y, width, height, fill) {\n    rect.setAttributeNS(null, 'x', x.toString());\n    rect.setAttributeNS(null, 'y', y.toString());\n    rect.setAttributeNS(null, 'height', height.toString());\n    rect.setAttributeNS(null, 'width', width.toString());\n    rect.setAttributeNS(null, 'fill', fill);\n}\nfunction svg_text(x, y, size, content, fill) {\n    var element = document.createElementNS(svgns, 'text');\n    element.setAttribute('x', x.toString());\n    element.setAttribute('y', y.toString());\n    element.setAttribute('fill', fill);\n    element.setAttribute('font-size', size.toString());\n    var txt = document.createTextNode(content);\n    element.appendChild(txt);\n    return element;\n}\nfunction svg_line(x1, y1, x2, y2, stroke) {\n    var line = document.createElementNS(svgns, 'line');\n    svg_update_line(line, x1, y1, x2, y2, stroke);\n    return line;\n}\nfunction svg_update_line(line, x1, y1, x2, y2, stroke) {\n    line.setAttribute('x1', x1.toString());\n    line.setAttribute('y1', y1.toString());\n    line.setAttribute('x2', x2.toString());\n    line.setAttribute('y2', y2.toString());\n    line.setAttribute(\"stroke\", stroke);\n}\n\n\n//# sourceURL=webpack://synth101-wam/../shared/ui/svg.ts?");

/***/ }),

/***/ "../shared/util.ts":
/*!*************************!*\
  !*** ../shared/util.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"token\": () => (/* binding */ token),\n/* harmony export */   \"constantSource\": () => (/* binding */ constantSource),\n/* harmony export */   \"noiseSource\": () => (/* binding */ noiseSource)\n/* harmony export */ });\nfunction token() {\n    return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 16);\n}\nfunction constantSource(audioContext) {\n    if (audioContext.createConstantSource) {\n        let source = audioContext.createConstantSource();\n        source.start();\n        return source;\n    }\n    else {\n        let length = audioContext.sampleRate;\n        var buffer = audioContext.createBuffer(1, length, audioContext.sampleRate);\n        var noise = buffer.getChannelData(0);\n        for (var i = 0; i < length; i++) {\n            noise[i] = 1.0;\n        }\n        var source = audioContext.createBufferSource();\n        source.buffer = buffer;\n        source.loop = true;\n        source.loopStart = 0.0;\n        source.loopEnd = 0.9;\n        source.start();\n        return source;\n    }\n}\nfunction noiseSource(audioContext) {\n    let length = audioContext.sampleRate;\n    var buffer = audioContext.createBuffer(1, length, audioContext.sampleRate);\n    var noise = buffer.getChannelData(0);\n    for (var i = 0; i < length; i++) {\n        noise[i] = (Math.random() * 2) - 1;\n    }\n    var source = audioContext.createBufferSource();\n    source.buffer = buffer;\n    source.loop = true;\n    source.loopStart = 0.0;\n    source.loopEnd = 0.9;\n    source.start();\n    return source;\n}\n\n\n//# sourceURL=webpack://synth101-wam/../shared/util.ts?");

/***/ }),

/***/ "./src/Node.ts":
/*!*********************!*\
  !*** ./src/Node.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Synth101Node)\n/* harmony export */ });\n/* harmony import */ var _webaudiomodules_sdk_parammgr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @webaudiomodules/sdk-parammgr */ \"../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js\");\n/* harmony import */ var _shared_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/util */ \"../shared/util.ts\");\n/* harmony import */ var _shared_midi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/midi */ \"../shared/midi.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nlet lfoWaves = [\"triangle\", \"square\"];\nlet shaperLength = 44100;\nclass Synth101Node extends _webaudiomodules_sdk_parammgr__WEBPACK_IMPORTED_MODULE_0__.CompositeAudioNode {\n    constructor(audioContext, options = {}) {\n        super(audioContext, options);\n        this.parameters = {\n            lfoRate: 0,\n            lfoWaveform: 0,\n            oscMod: 0,\n            oscRange: 0,\n            pulseWidth: 0,\n            pwmSource: 0,\n            subRange: 0,\n            filterFreq: 0.35,\n            filterKeyboard: 0,\n            vcaSource: 0,\n            envAttack: 0,\n            envDecay: 0.1,\n            envSustain: 0,\n            envRelease: 0,\n            portamentoMode: 0,\n            portamentoTime: 0,\n        };\n        this._wamNode = undefined;\n        this.isEnabled = true;\n        this.heldNotes = [];\n        this.heldNotes.length = 128;\n        this.heldNotes.fill(false, 0, 128);\n        this.targetFreq = 0;\n        this.currentNote = -1;\n        this.createNodes();\n    }\n    get paramMgr() {\n        return this._wamNode;\n    }\n    getAutomationState() {\n        const _super = Object.create(null, {\n            getState: { get: () => super.getState }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let orig = yield _super.getState.call(this);\n            let state = {};\n            Object.keys(orig).forEach(k => state[k] = orig[k].value);\n            return state;\n        });\n    }\n    setup(paramMgr) {\n        paramMgr.addEventListener('wam-midi', (e) => this.processMIDIEvents([{ event: e.detail.data.bytes, time: 0 }]));\n        this._wamNode = paramMgr;\n    }\n    set status(_sig) {\n        this.isEnabled = _sig;\n    }\n    createNodes() {\n        this.oscillator = this.context.createOscillator();\n        this.oscillator.type = \"sawtooth\";\n        this.pulseGain = this.context.createGain();\n        this.pulseShaper = this.context.createWaveShaper();\n        var curve = new Float32Array(shaperLength);\n        let quarter = shaperLength / 4;\n        for (var i = 0; i < shaperLength; i++) {\n            if (i < quarter) {\n                curve[i] = -1.0;\n            }\n            else if (i > quarter * 3) {\n                curve[i] = -1.0;\n            }\n            else {\n                curve[i] = 1.0;\n            }\n        }\n        this.pulseShaper.curve = curve;\n        this.subOsc = this.context.createOscillator();\n        this.subOsc.type = \"square\";\n        this.lfo = this.context.createOscillator();\n        this.lfo.type = \"triangle\";\n        this.lfoPWM = this.context.createGain();\n        this.lfoFilter = this.context.createGain();\n        this.lfoOscMod = this.context.createGain();\n        this.lfo.connect(this.lfoPWM);\n        this.lfo.connect(this.lfoOscMod);\n        this.lfo.connect(this.lfoFilter);\n        this.lfoOscMod.connect(this.oscillator.detune);\n        this.lfoOscMod.connect(this.subOsc.detune);\n        this.env = new AudioWorkletNode(this.context, 'envelope-generator-processor');\n        this.gateSlew = new AudioWorkletNode(this.context, 'slew-processor');\n        this.gateSlew.parameters.get(\"riseSpeed\").setValueAtTime(0.1, 0);\n        this.gateSlew.parameters.get(\"fallSpeed\").setValueAtTime(0.1, 0);\n        this.envFilter = this.context.createGain();\n        this.envVCA = this.context.createGain();\n        this.envPWM = this.context.createGain();\n        this.kybdSource = (0,_shared_util__WEBPACK_IMPORTED_MODULE_1__.constantSource)(this.context);\n        this.kybdGain = this.context.createGain();\n        this.kybdSource.connect(this.kybdGain);\n        this.filters = [\n            this.context.createBiquadFilter(),\n            this.context.createBiquadFilter(),\n            this.context.createBiquadFilter(),\n        ];\n        this.filters.forEach(filter => {\n            filter.type = \"lowpass\";\n            this.lfoFilter.connect(filter.detune);\n            this.envFilter.connect(filter.detune);\n            this.kybdGain.connect(filter.detune);\n        });\n        this.mixerSaw = this.context.createGain();\n        this.mixerPulse = this.context.createGain();\n        this.mixerSub = this.context.createGain();\n        this.mixerNoise = this.context.createGain();\n        this.vca = this.context.createGain();\n        this.vca.gain.setValueAtTime(0, 0);\n        this.oscillator.start(0);\n        this.lfo.start(0);\n        this.subOsc.start(0);\n        this.oscillator.connect(this.mixerSaw);\n        this.mixerSaw.connect(this.filters[0]);\n        this.lfoPWM.connect(this.pulseGain.gain);\n        this.envPWM.connect(this.pulseGain.gain);\n        this.oscillator.connect(this.pulseGain);\n        this.pulseGain.connect(this.pulseShaper);\n        this.pulseShaper.connect(this.mixerPulse);\n        this.mixerPulse.connect(this.filters[0]);\n        this.subOsc.connect(this.mixerSub);\n        this.mixerSub.connect(this.filters[0]);\n        this.filters[0].connect(this.filters[1]);\n        this.filters[1].connect(this.filters[2]);\n        this.filters[2].connect(this.vca);\n        let noise = (0,_shared_util__WEBPACK_IMPORTED_MODULE_1__.noiseSource)(this.context);\n        noise.connect(this.mixerNoise);\n        this.mixerNoise.connect(this.filters[0]);\n        this.env.connect(this.envFilter);\n        this.env.connect(this.envVCA);\n        this.env.connect(this.envPWM);\n        this.envVCA.connect(this.vca.gain);\n        this.gateSlew.connect(this.vca.gain);\n        this._output = this.context.createChannelMerger(2);\n        this.vca.connect(this._output, 0, 0);\n        this.vca.connect(this._output, 0, 1);\n        this.updateFromState();\n    }\n    processMIDIEvents(midiEvents) {\n        midiEvents.forEach(message => {\n            if (message.event[0] == _shared_midi__WEBPACK_IMPORTED_MODULE_2__.MIDI.NOTE_ON && message.event[2] > 0) {\n                let midiNote = message.event[1];\n                this.noteOn(midiNote, message.time);\n            }\n            else if (message.event[0] == _shared_midi__WEBPACK_IMPORTED_MODULE_2__.MIDI.NOTE_OFF || (message.event[0] == _shared_midi__WEBPACK_IMPORTED_MODULE_2__.MIDI.NOTE_ON && message.event[2] == 0)) {\n                let midiNote = message.event[1];\n                this.noteOff(midiNote, message.time);\n            }\n        });\n    }\n    noteOn(note, tickStartTime) {\n        this.heldNotes[note] = true;\n        this.noteUpdate(tickStartTime);\n    }\n    noteOff(note, tickStartTime) {\n        this.heldNotes[note] = false;\n        this.noteUpdate(tickStartTime);\n    }\n    allNotesOff(tickStartTime) {\n        this.heldNotes.fill(false, 0, 128);\n        this.noteUpdate(tickStartTime);\n    }\n    setPitch(note, tickStartTime, portamento) {\n        let rangeMultiples = [0.5, 1, 2, 4];\n        this.targetFreq = 440 * Math.pow(2, ((note - 69) / 12)) * rangeMultiples[this.parameters.oscRange];\n        let time = portamento ? this.parameters.portamentoTime / 5 : 0;\n        this.oscillator.frequency.setTargetAtTime(this.targetFreq, tickStartTime, time);\n        this.subOsc.frequency.setTargetAtTime(this.targetFreq, tickStartTime, time);\n        this.kybdGain.gain.setTargetAtTime((note - 69) * 100 * this.parameters.filterKeyboard, tickStartTime, time);\n    }\n    noteUpdate(tickStartTime) {\n        let absoluteStartTime = tickStartTime + this.context.currentTime;\n        for (var i = this.heldNotes.length - 1; i >= 0; i--) {\n            if (this.heldNotes[i]) {\n                break;\n            }\n        }\n        if (i == -1 && this.currentNote > 0) {\n            this.env.port.postMessage({ event: \"trigger\", high: false, time: tickStartTime });\n            this.gateSlew.parameters.get(\"input\").setValueAtTime(0, tickStartTime);\n            this.currentNote = -1;\n        }\n        if (i > -1 && this.currentNote != i) {\n            let portamento = (this.parameters.portamentoMode == 2 || (this.parameters.portamentoMode == 1 && this.currentNote != -1));\n            this.setPitch(i, absoluteStartTime, portamento);\n            if (this.currentNote == -1) {\n                this.env.port.postMessage({ event: \"trigger\", high: true, time: tickStartTime });\n                this.gateSlew.parameters.get(\"input\").setValueAtTime(1.0, tickStartTime);\n            }\n            this.currentNote = i;\n        }\n    }\n    updateFromState() {\n        let state = this.parameters;\n        if (!this.oscillator) {\n            return;\n        }\n        if (state.subRange == 0) {\n            this.subOsc.detune.setValueAtTime(-1200, 0);\n        }\n        else {\n            this.subOsc.detune.setValueAtTime(-2400, 0);\n        }\n        let subWaves = [\"square\", \"square\", \"sine\", \"triangle\"];\n        this.subOsc.type = subWaves[state.subRange];\n        if (state.pwmSource == 0) {\n            this.pulseGain.gain.setValueAtTime(1.0, 0);\n            this.envPWM.gain.setValueAtTime(0, 0);\n            this.lfoPWM.gain.setValueAtTime(state.pulseWidth * 0.2, 0);\n        }\n        else if (state.pwmSource == 1) {\n            this.lfoPWM.gain.setValueAtTime(0, 0);\n            this.envPWM.gain.setValueAtTime(0, 0);\n            this.pulseGain.gain.setValueAtTime(1.0 - (state.pulseWidth * 0.4), 0);\n        }\n        else if (state.pwmSource == 2) {\n            this.pulseGain.gain.setValueAtTime(1.0, 0);\n            this.lfoPWM.gain.setValueAtTime(0, 0);\n            this.envPWM.gain.setValueAtTime(state.pulseWidth * -0.5, 0);\n        }\n        this.lfo.type = lfoWaves[state.lfoWaveform];\n        let lfoFrequency = 0.1 + (29.9 * state.lfoRate * state.lfoRate);\n        this.lfo.frequency.setValueAtTime(lfoFrequency, 0);\n        let baseFreq = 10 + (19990 * state.filterFreq * state.filterFreq);\n        this.filters.forEach(filter => {\n            filter.frequency.linearRampToValueAtTime(baseFreq, this.context.currentTime + 0.01);\n        });\n        if (state.vcaSource == 0) {\n            this.envVCA.gain.setValueAtTime(1, 0);\n            this.gateSlew.parameters.get(\"gain\").setValueAtTime(0, 0);\n        }\n        else {\n            this.envVCA.gain.setValueAtTime(0, 0);\n            this.gateSlew.parameters.get(\"gain\").setValueAtTime(1, 0);\n        }\n    }\n    destroy() {\n        this.gateSlew.parameters.get(\"destroyed\").setValueAtTime(1, 0);\n        this.env.parameters.get(\"destroyed\").setValueAtTime(1, 0);\n        super.destroy();\n    }\n}\n\n\n//# sourceURL=webpack://synth101-wam/./src/Node.ts?");

/***/ }),

/***/ "./src/SynthView.tsx":
/*!***************************!*\
  !*** ./src/SynthView.tsx ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SynthView\": () => (/* binding */ SynthView)\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _shared_ui_Knob__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shared/ui/Knob */ \"../shared/ui/Knob.tsx\");\n/* harmony import */ var _shared_ui_Select__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shared/ui/Select */ \"../shared/ui/Select.tsx\");\n/* harmony import */ var _shared_ui_Fader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../shared/ui/Fader */ \"../shared/ui/Fader.tsx\");\n/* harmony import */ var _Synth101_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Synth101.scss */ \"./src/Synth101.scss\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nlet waves = [\"sine\", \"square\", \"sawtooth\", \"triangle\"];\nlet lfoWaves = [\"triangle\", \"square\"];\nlet ranges = [\"32'\", \"16'\", \"8'\", \"4'\"];\nlet pwms = [\"LFO\", \"Manual\", \"Env\"];\nlet subRanges = [\"-10ct\", \"-20ct pulse\", \"-20ct sine\", \"-20ct tri\"];\nlet vcaSources = [\"Env\", \"Gate\"];\nlet envTriggers = [\"Gate\", \"Trig\", \"Both\"];\nlet portamentoModes = [\"Off\", \"Auto\", \"On\"];\n\nlet styles = _Synth101_scss__WEBPACK_IMPORTED_MODULE_4__.default.locals;\nclass SynthView extends preact__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super();\n        this.pollAutomationState = this.pollAutomationState.bind(this);\n    }\n    componentDidMount() {\n        this.wamState = this.props.initialState;\n        this.automationStatePoller = window.requestAnimationFrame(this.pollAutomationState);\n    }\n    componentWillUnmount() {\n        window.cancelAnimationFrame(this.automationStatePoller);\n    }\n    parameterChanged(name, value) {\n        this.wamState[name] = value;\n        this.props.plugin.audioNode.paramMgr.setParamValue(name, value);\n    }\n    pollAutomationState() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.wamState = this.props.plugin.audioNode.paramMgr.getParamsValues();\n            this.automationStatePoller = window.requestAnimationFrame(this.pollAutomationState);\n        });\n    }\n    value(name) {\n        if (this.wamState && this.wamState[name]) {\n            return this.wamState[name];\n        }\n        else {\n            return 0;\n        }\n    }\n    render() {\n        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", {});\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.root },\n            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.synth101 },\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.section },\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.header }, \"Portamento\"),\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.content, style: \"flex-direction: column\" },\n                        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Knob__WEBPACK_IMPORTED_MODULE_1__.Knob, { label: \"Time\", value: () => this.value(\"portamentoTime\"), onChange: (e) => this.parameterChanged(\"portamentoTime\", e) }),\n                        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Select__WEBPACK_IMPORTED_MODULE_2__.Select, { label: \"Mode\", options: portamentoModes, value: () => this.value(\"portamentoMode\"), onChange: (e) => this.parameterChanged(\"portamentoMode\", parseInt(e)) }))),\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.section },\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.header }, \"LFO\"),\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.content, style: \"flex-direction: column\" },\n                        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Knob__WEBPACK_IMPORTED_MODULE_1__.Knob, { label: \"Rate\", value: () => this.value(\"lfoRate\"), onChange: (e) => this.parameterChanged(\"lfoRate\", e) }),\n                        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Select__WEBPACK_IMPORTED_MODULE_2__.Select, { label: \"Waveform\", options: lfoWaves, value: () => this.value(\"lfoWaveform\"), onChange: (e) => this.parameterChanged(\"lfoWaveform\", parseInt(e)) }))),\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.section },\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.header }, \"Oscillator\"),\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.content },\n                        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { style: \"display: flex; flex-direction: column\" },\n                            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Knob__WEBPACK_IMPORTED_MODULE_1__.Knob, { label: \"Tune\", value: () => this.value(\"detune\"), minimumValue: -1.0, maximumValue: 1.0, bipolar: true, onChange: (e) => this.parameterChanged(\"detune\", e) }),\n                            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Select__WEBPACK_IMPORTED_MODULE_2__.Select, { label: \"Range\", options: ranges, value: () => this.value(\"oscRange\"), onChange: (e) => this.parameterChanged(\"oscRange\", parseInt(e)) })),\n                        this.fader(\"Mod\", \"oscMod\"),\n                        this.fader(\"PW\", \"pulseWidth\"),\n                        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { style: \"display: flex; flex-direction: column\" },\n                            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Select__WEBPACK_IMPORTED_MODULE_2__.Select, { label: \"PWM\", options: pwms, value: () => this.value(\"pwmSource\"), onChange: (e) => this.parameterChanged(\"pwmSource\", parseInt(e)) }),\n                            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Select__WEBPACK_IMPORTED_MODULE_2__.Select, { label: \"Sub Range\", options: subRanges, value: () => this.value(\"subRange\"), onChange: (e) => this.parameterChanged(\"subRange\", parseInt(e)) })))),\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.section },\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.header }, \"Mixer\"),\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.content },\n                        this.fader(\"Pulse\", \"mixerPulse\"),\n                        this.fader(\"Saw\", \"mixerSaw\"),\n                        this.fader(\"Sub\", \"mixerSub\"),\n                        this.fader(\"Noise\", \"mixerNoise\"))),\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.section },\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.header }, \"Filter\"),\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.content },\n                        this.fader(\"Freq\", \"filterFreq\"),\n                        this.fader(\"Res\", \"filterRes\"),\n                        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { style: \"width: 10px;\" }, \" \"),\n                        this.fader(\"Env\", \"filterEnv\"),\n                        this.fader(\"Mod\", \"filterMod\"),\n                        this.fader(\"Kybd\", \"filterKeyboard\"))),\n                (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.section },\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.header }, \"VCA / Env\"),\n                    (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { class: styles.content },\n                        (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(\"div\", { style: \"display: flex; flex-direction: column\" },\n                            (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Select__WEBPACK_IMPORTED_MODULE_2__.Select, { label: \"VCA\", options: vcaSources, value: () => this.value(\"vcaSource\"), onChange: (e) => this.parameterChanged(\"vcaSource\", parseInt(e)) })),\n                        this.fader(\"A\", \"envAttack\"),\n                        this.fader(\"D\", \"envDecay\"),\n                        this.fader(\"S\", \"envSustain\"),\n                        this.fader(\"R\", \"envRelease\")))));\n    }\n    fader(label, param) {\n        return (0,preact__WEBPACK_IMPORTED_MODULE_0__.h)(_shared_ui_Fader__WEBPACK_IMPORTED_MODULE_3__.Fader, { label: label, value: () => this.value(param), onChange: (e) => this.parameterChanged(param, e) });\n    }\n}\n\n\n//# sourceURL=webpack://synth101-wam/./src/SynthView.tsx?");

/***/ }),

/***/ "./src/index.tsx":
/*!***********************!*\
  !*** ./src/index.tsx ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Synth101)\n/* harmony export */ });\n/* harmony import */ var _webaudiomodules_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @webaudiomodules/sdk */ \"../../../node_modules/@webaudiomodules/sdk/dist/index.js\");\n/* harmony import */ var _webaudiomodules_sdk_parammgr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @webaudiomodules/sdk-parammgr */ \"../../../node_modules/@webaudiomodules/sdk-parammgr/dist/index.js\");\n/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Node */ \"./src/Node.ts\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var _SynthView__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SynthView */ \"./src/SynthView.tsx\");\n/* harmony import */ var _shared_getBaseUrl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../shared/getBaseUrl */ \"../shared/getBaseUrl.tsx\");\n/* harmony import */ var _Synth101_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Synth101.scss */ \"./src/Synth101.scss\");\n/* harmony import */ var _shared_insertStyle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../shared/insertStyle */ \"../shared/insertStyle.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\nlet lfoWaves = [\"triangle\", \"square\"];\nlet ranges = [\"32'\", \"16'\", \"8'\", \"4'\"];\nlet pwms = [\"LFO\", \"Manual\", \"Env\"];\nlet subRanges = [\"-10ct\", \"-20ct pulse\", \"-20ct sine\", \"-20ct tri\"];\nlet vcaSources = [\"Env\", \"Gate\"];\nlet portamentoModes = [\"Off\", \"Auto\", \"On\"];\nfunction normalize(v, min, max, int = false) {\n    return Math.max(min, Math.min(max, int ? Math.floor(v) : v));\n}\nclass Synth101 extends _webaudiomodules_sdk__WEBPACK_IMPORTED_MODULE_0__.WebAudioModule {\n    constructor() {\n        super(...arguments);\n        this._baseURL = (0,_shared_getBaseUrl__WEBPACK_IMPORTED_MODULE_5__.getBaseUrl)(new URL('.', __webpack_require__.p));\n        this._descriptorUrl = `${this._baseURL}/descriptor.json`;\n        this._envelopeGeneratorUrl = `${this._baseURL}/EnvelopeGeneratorProcessor.js`;\n        this._slewUrl = `${this._baseURL}/SlewProcessor.js`;\n    }\n    _loadDescriptor() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = this._descriptorUrl;\n            if (!url)\n                throw new TypeError('Descriptor not found');\n            const response = yield fetch(url);\n            const descriptor = yield response.json();\n            Object.assign(this._descriptor, descriptor);\n            return descriptor;\n        });\n    }\n    initialize(state) {\n        const _super = Object.create(null, {\n            initialize: { get: () => super.initialize }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._loadDescriptor();\n            yield this.audioContext.audioWorklet.addModule(this._envelopeGeneratorUrl);\n            yield this.audioContext.audioWorklet.addModule(this._slewUrl);\n            return _super.initialize.call(this, state);\n        });\n    }\n    createAudioNode(initialState) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const synthNode = new _Node__WEBPACK_IMPORTED_MODULE_2__.default(this.audioContext);\n            const paramsConfig = {\n                detune: {\n                    defaultValue: 0,\n                    minValue: -1,\n                    maxValue: 1\n                },\n                lfoRate: {\n                    defaultValue: 0.2,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                lfoWaveform: {\n                    defaultValue: 0,\n                    type: 'choice',\n                    choices: lfoWaves\n                },\n                oscMod: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1,\n                    exponent: 2,\n                },\n                oscRange: {\n                    defaultValue: 0,\n                    type: 'choice',\n                    choices: ranges,\n                    discreteStep: 1,\n                    minValue: 0,\n                    maxValue: ranges.length\n                },\n                pulseWidth: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                pwmSource: {\n                    defaultValue: 0,\n                    type: 'choice',\n                    choices: pwms\n                },\n                subRange: {\n                    defaultValue: 0,\n                    type: 'choice',\n                    choices: subRanges\n                },\n                mixerSaw: {\n                    defaultValue: 1,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                mixerPulse: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                mixerSub: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                mixerNoise: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                filterFreq: {\n                    defaultValue: 0.2,\n                    minValue: 0,\n                    maxValue: 1,\n                },\n                filterRes: {\n                    defaultValue: 0.05,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                filterEnv: {\n                    defaultValue: 0.15,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                filterMod: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                filterKeyboard: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                vcaSource: {\n                    defaultValue: 0,\n                    type: 'choice',\n                    choices: vcaSources\n                },\n                envAttack: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                envDecay: {\n                    defaultValue: 0.2,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                envSustain: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                envRelease: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                },\n                portamentoMode: {\n                    defaultValue: 0,\n                    type: 'choice',\n                    choices: portamentoModes,\n                },\n                portamentoTime: {\n                    defaultValue: 0,\n                    minValue: 0,\n                    maxValue: 1\n                }\n            };\n            const internalParamsConfig = {\n                detune: synthNode.oscillator.detune,\n                lfoRate: {\n                    onChange: (v) => { synthNode.parameters.lfoRate = normalize(v, 0, 1); synthNode.updateFromState(); },\n                    automationRate: 30,\n                },\n                lfoWaveform: {\n                    onChange: (v) => { let n = normalize(v, 0, lfoWaves.length - 1, true); synthNode.parameters.lfoWaveform = n; synthNode.updateFromState(); },\n                    automationRate: 30,\n                },\n                oscMod: synthNode.lfoOscMod.gain,\n                oscRange: {\n                    onChange: (v) => { let n = normalize(v, 0, ranges.length - 1, true); synthNode.parameters.oscRange = n; synthNode.updateFromState(); },\n                    automationRate: 30,\n                },\n                pulseWidth: {\n                    onChange: (v) => { synthNode.parameters.pulseWidth = normalize(v, 0, 1); synthNode.updateFromState(); },\n                    automationRate: 30,\n                },\n                pwmSource: {\n                    onChange: (v) => { synthNode.parameters.pwmSource = normalize(v, 0, pwms.length - 1, true); synthNode.updateFromState(); },\n                    automationRate: 20,\n                },\n                subRange: {\n                    onChange: (v) => { synthNode.parameters.subRange = normalize(v, 0, subRanges.length - 1, true); synthNode.updateFromState(); },\n                    automationRate: 30\n                },\n                mixerSaw: synthNode.mixerSaw.gain,\n                mixerPulse: synthNode.mixerPulse.gain,\n                mixerSub: synthNode.mixerSub.gain,\n                mixerNoise: synthNode.mixerNoise.gain,\n                filterFreq: {\n                    onChange: (v) => { synthNode.parameters.filterFreq = normalize(v, 0, 1); synthNode.updateFromState(); },\n                    automationRate: 30,\n                },\n                filterRes1: synthNode.filters[0].Q,\n                filterRes2: synthNode.filters[1].Q,\n                filterRes3: synthNode.filters[2].Q,\n                filterEnv: synthNode.envFilter.gain,\n                filterMod: synthNode.lfoFilter.gain,\n                filterKeyboard: {\n                    onChange: (v) => { synthNode.parameters.filterKeyboard = normalize(v, 0, 1); }\n                },\n                vcaSource: {\n                    onChange: (v) => { synthNode.parameters.vcaSource = normalize(v, 0, vcaSources.length - 1, true); synthNode.updateFromState(); }\n                },\n                envAttack: synthNode.env.parameters.get(\"attackTime\"),\n                envDecay: synthNode.env.parameters.get(\"decayTime\"),\n                envSustain: synthNode.env.parameters.get(\"sustain\"),\n                envRelease: synthNode.env.parameters.get(\"releaseTime\"),\n                portamentoMode: {\n                    onChange: (v) => { synthNode.parameters.portamentoMode = normalize(v, 0, portamentoModes.length - 1, true); }\n                },\n                portamentoTime: {\n                    onChange: (v) => { synthNode.parameters.portamentoTime = normalize(v, 0, 1); }\n                }\n            };\n            const paramsMapping = {\n                detune: {\n                    detune: {\n                        sourceRange: [-1, 1],\n                        targetRange: [-100, 100]\n                    }\n                },\n                filterRes: {\n                    filterRes1: {\n                        sourceRange: [0, 1],\n                        targetRange: [0, 8]\n                    },\n                    filterRes2: {\n                        sourceRange: [0, 1],\n                        targetRange: [0, 8]\n                    },\n                    filterRes3: {\n                        sourceRange: [0, 1],\n                        targetRange: [0, 8]\n                    }\n                },\n                filterMod: {\n                    filterMod: {\n                        sourceRange: [0, 1],\n                        targetRange: [0, 2400]\n                    }\n                },\n                filterEnv: {\n                    filterEnv: {\n                        sourceRange: [0, 1],\n                        targetRange: [0, 2400]\n                    }\n                },\n                oscMod: {\n                    oscMod: {\n                        sourceRange: [0, 1],\n                        targetRange: [0, 200]\n                    }\n                }\n            };\n            const optionsIn = { internalParamsConfig, paramsConfig, paramsMapping };\n            const paramMgrNode = yield _webaudiomodules_sdk_parammgr__WEBPACK_IMPORTED_MODULE_1__.ParamMgrFactory.create(this, optionsIn);\n            synthNode.setup(paramMgrNode);\n            if (initialState)\n                synthNode.setState(initialState);\n            return synthNode;\n        });\n    }\n    createGui() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const div = document.createElement('div');\n            (0,preact__WEBPACK_IMPORTED_MODULE_3__.h)(\"div\", {});\n            div.setAttribute(\"style\", \"display: flex; height: 100%; width: 100%; flex: 1;\");\n            var shadow = div.attachShadow({ mode: 'open' });\n            (0,_shared_insertStyle__WEBPACK_IMPORTED_MODULE_7__.insertStyle)(shadow, _Synth101_scss__WEBPACK_IMPORTED_MODULE_6__.default.toString());\n            let initialState = this.audioNode.paramMgr.getParamsValues();\n            (0,preact__WEBPACK_IMPORTED_MODULE_3__.render)((0,preact__WEBPACK_IMPORTED_MODULE_3__.h)(_SynthView__WEBPACK_IMPORTED_MODULE_4__.SynthView, { initialState: initialState, plugin: this }), shadow);\n            return div;\n        });\n    }\n    destroyGui(el) {\n        (0,preact__WEBPACK_IMPORTED_MODULE_3__.render)(null, el.shadowRoot);\n    }\n}\n\n\n//# sourceURL=webpack://synth101-wam/./src/index.tsx?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	var scriptUrl;
/******/ 	if (typeof import.meta.url === "string") scriptUrl = import.meta.url
/******/ 	// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 	// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 	if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 	scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 	__webpack_require__.p = scriptUrl;
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/index.tsx");
/******/ var __webpack_exports__default = __webpack_exports__.default;
/******/ export { __webpack_exports__default as default };
/******/ 
